<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Flight Starfield</title>
    <style>
        /* Remove default margin and ensure canvas fills viewport */
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        /* Ensure canvas displays as block element */
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="starfield"></canvas>
    <script>
        // Get canvas element and context
        const canvas = document.getElementById('starfield');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Steering variables
        let steeringX = 0; // -1 to 1 for left/right steering
        let steeringY = 0; // -1 to 1 for up/down steering

        // Keyboard event handlers
        function handleKeyDown(event) {
            switch(event.key) {
                case 'ArrowLeft':
                    steeringX = -1;
                    break;
                case 'ArrowRight':
                    steeringX = 1;
                    break;
                case 'ArrowUp':
                    steeringY = -1;
                    break;
                case 'ArrowDown':
                    steeringY = 1;
                    break;
            }
        }

        function handleKeyUp(event) {
            switch(event.key) {
                case 'ArrowLeft':
                case 'ArrowRight':
                    steeringX = 0;
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                    steeringY = 0;
                    break;
            }
        }

        // Add keyboard event listeners
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // Helper function to generate random point in sphere
        function randomPointInSphere(minRadius, maxRadius) {
            // Generate random angles for spherical coordinates
            const theta = Math.random() * 2 * Math.PI; // Azimuthal angle (0 to 2π)
            const phi = Math.acos(2 * Math.random() - 1); // Polar angle (0 to π) with correct distribution
            
            // Generate radius with cubic root for uniform volume distribution
            const u = Math.random();
            const radius = minRadius + (maxRadius - minRadius) * Math.cbrt(u);
            
            // Convert spherical to cartesian coordinates
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            return { x, y, z };
        }

        // Alternative: Generate random point on sphere surface (for stars at specific distances)
        function randomPointOnSphere(radius) {
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            return { x, y, z };
        }

        class Star {
            constructor() {
                // Use spherical distribution for better star placement
                const point = randomPointInSphere(500, 4500);
                this.x = point.x;
                this.y = point.y;
                this.z = point.z;
                this.size = Math.random() * 0.2 + 0.5;
            }

            update(speed) {
                // Move star forward along z-axis
                this.z -= speed;
                
                // Apply parallax-based steering effect
                // Closer stars (smaller z) are more affected by steering
                // Use inverse relationship: closer = more movement
                const parallaxFactor = 2000 / this.z; // Adjust 2000 to control sensitivity
                const maxParallax = 8; // Cap the maximum movement per frame
                
                // Calculate movement with proper clamping that preserves direction
                const rawParallaxX = steeringX * parallaxFactor;
                const rawParallaxY = steeringY * parallaxFactor;
                
                const parallaxX = Math.max(-maxParallax, Math.min(maxParallax, rawParallaxX));
                const parallaxY = Math.max(-maxParallax, Math.min(maxParallax, rawParallaxY));
                
                this.x += parallaxX;
                this.y += parallaxY;
                
                // Reset star when it gets too close
                if (this.z <= 0) {
                    // Create new star at a far distance with spherical distribution
                    const point = randomPointOnSphere(4500);
                    this.x = point.x;
                    this.y = point.y;
                    this.z = point.z;
                }
            }

            draw() {
                // Skip stars behind the camera
                if (this.z <= 0) return;
                
                // Perspective projection
                const k = 500 / this.z;
                const px = this.x * k + canvas.width/2;
                const py = this.y * k + canvas.height/2;
                
                // Only draw stars that are visible on screen (with some margin)
                const margin = 50;
                if (px < -margin || px > canvas.width + margin || 
                    py < -margin || py > canvas.height + margin) {
                    return;
                }
                
                // Calculate size with maximum limit
                const maxSize = 3;
                const size = Math.min(this.size * k, maxSize);
                
                // Add brightness variation based on distance
                const brightness = Math.max(0.3, Math.min(1, 1000 / this.z));
                
                // Draw star with varying brightness
                ctx.beginPath();
                ctx.arc(px, py, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                ctx.fill();
            }
        }
               
        // Create stars
        const stars = [];
        const numberOfStars = 300; // Increased for better density

        // Initialize stars
        for (let i = 0; i < numberOfStars; i++) {
            stars.push(new Star());
        }

        // Animation variables
        let lastTime = 0;
        const speed = 2;

        function animate(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Create trailing effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw stars
            stars.forEach(star => {
                star.update(speed);
                star.draw();
            });

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>
