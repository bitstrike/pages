<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Box Generator üé®</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            margin: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1, h2 {
            color: #ff6f61;
        }
        form {
            background-color: #2c2c2c;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }
        label {
            display: block;
            margin-top: 10px;
            color: #ffcc00;
        }
        textarea, input, select {
            width: 95%;
            padding: 10px;
            margin-top: 5px;
            border: 1px solid #444;
            border-radius: 5px;
            background-color: #3a3a3a;
            color: #e0e0e0;
        }
        input[type="submit"] {
            background-color: #ff6f61;
            color: #1e1e1e;
            border: none;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
        }
        input[type="submit"]:hover {
            background-color: #ff8f73;
        }
        .box {
            font-family: monospace;
            white-space: pre;
            background-color: #3a3a3a;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .style-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>ASCII Box Generator üé®</h1>
    <form id="boxForm">
        <label for="message">üìù Message:</label>
        <textarea id="message" name="message" rows="4" required></textarea>
        <div class="style-controls">
            <div>
                <label for="boxStyle">üé® Box Style:</label>
                <select id="boxStyle" name="boxStyle">
                    <option value="1">Single Line</option>
                    <option value="2" selected>Double Line</option>
                </select>
            </div>
            <div>
                <label for="commentStyle">üí¨ Comment:</label>
                <select id="commentStyle" name="commentStyle">
                    <option value="c">C code</option>
                    <option value="shell">Shell</option>
                    <option value="python">Python</option>
                </select>
            </div>
        </div>
        <label for="maxLength">üìè Max Length:</label>
        <input type="number" id="maxLength" name="maxLength" min="1">
        <input type="submit" value="Generate Box üöÄ">
    </form>
    <h2>Generated Box:</h2>
    <div id="output" class="box"></div>
    <script>
        const messageInput = document.getElementById('message');
        // Constants for comment styles
        const SHELL = 100;
        const CLANG = 101;
        const PYTHON = 102;

        // Handle paste events
        messageInput.addEventListener('paste', function(e) {
            e.preventDefault();
            const pastedText = e.clipboardData.getData('text/plain');
            const cleanText = pastedText.replace(/[\r\n\t]/g, ' ');
            const cursorPosition = this.selectionStart;
            const textBefore = this.value.substring(0, cursorPosition);
            const textAfter = this.value.substring(cursorPosition);
            this.value = textBefore + cleanText + textAfter;
            this.selectionStart = cursorPosition + cleanText.length;
            this.selectionEnd = this.selectionStart;
            this.focus();
        });

        //  handle box and comment generation
        document.getElementById('boxForm').addEventListener('submit', function(event) {
        event.preventDefault();
        const message = document.getElementById('message').value;
        const boxStyle = parseInt(document.getElementById('boxStyle').value);
        const commentStyle = document.getElementById('commentStyle').value;
        const maxLength = document.getElementById('maxLength').value !== '' ? parseInt(document.getElementById('maxLength').value) : null;
        
   

        document.getElementById('boxForm').addEventListener('submit', function(event) {
            event.preventDefault();
            const message = document.getElementById('message').value;
            const boxStyle = parseInt(document.getElementById('boxStyle').value);
            const commentStyle = document.getElementById('commentStyle').value;
            const maxLength = document.getElementById('maxLength').value !== '' ? parseInt(document.getElementById('maxLength').value) : null;
            
            // First create the box with proper line wrapping
            const box = createBox(message, boxStyle, maxLength);
            
            // Then format as comment if a comment style is selected
            const formattedOutput = formatComment(box, null, commentStyle);
            
            document.getElementById('output').textContent = formattedOutput;
        });

        document.getElementById('commentStyle').addEventListener('change', function() {
            const output = document.getElementById('output');
            if (output.textContent) {
                // Get the current message (not the formatted output)
                const message = document.getElementById('message').value;
                const boxStyle = parseInt(document.getElementById('boxStyle').value);
                const maxLength = document.getElementById('maxLength').value !== '' ? parseInt(document.getElementById('maxLength').value) : null;
                
                // Recreate the box
                const box = createBox(message, boxStyle, maxLength);
                
                // Format with the new comment style
                const formattedOutput = formatComment(box, null, this.value);
                output.textContent = formattedOutput;
            }
        });


        // First create the box
        const box = createBox(message, boxStyle, maxLength);
        
        // Then format as comment if needed
        const formattedOutput = formatComment(box, maxLength, commentStyle);
        
        document.getElementById('output').textContent = formattedOutput;
        });

        // Function to create the box
        function createBox(origMessage, boxStyle = 2, maxLength = null) {
            let topBottom, corners, vertical;
            if (boxStyle === 1) {
                topBottom = '‚îÄ';
                corners = '‚îå‚îê‚îî‚îò';
                vertical = '‚îÇ';
            } else {
                topBottom = '‚ïê';
                corners = '‚ïî‚ïó‚ïö‚ïù';
                vertical = '‚ïë';
            }
            
            // First wrap the text based on maxLength (if provided)
            let lines;
            if (maxLength && origMessage.length > maxLength) {
                lines = wrapText(origMessage, maxLength);
            } else {
                lines = [origMessage];
            }
            
            // Add padding around each line
            const paddedLines = lines.map(line => ' ' + line + ' ');
            
            // Find the width needed for the box (based on the longest line)
            const contentWidth = Math.max(...paddedLines.map(line => line.length));
            
            // Create the box elements
            const top = `${corners[0]}${topBottom.repeat(contentWidth)}${corners[1]}`;
            const bottom = `${corners[2]}${topBottom.repeat(contentWidth)}${corners[3]}‚ñë`;
            
            // Ensure all content lines are the same width for a uniform box
            const content = paddedLines.map(line => {
                const padded = line.padEnd(contentWidth);
                return `${vertical}${padded}${vertical}‚ñë`;
            });
            
            // Create the shadow
            const shadowWidth = contentWidth + 1;
            const shadow = "  " + "‚ñë".repeat(shadowWidth);
            
            // Return the complete box
            return [top, ...content, bottom, shadow].join('\n');
            }
        

        function wrapText(text, maxLength) {
            const words = text.split(' ');
            const lines = [];
            let tempLine = '';
            words.forEach(word => {
                if ((tempLine + word).length > maxLength) {
                    lines.push(tempLine.trim());
                    tempLine = '';
                }
                tempLine += (tempLine ? ' ' : '') + word;
            });
            lines.push(tempLine.trim());
            return lines;
        }


        // Function to format text as a comment in the specified style
        // Function to format text as a comment in the specified style
        function formatComment(buf, maxLength, style) {
        // Input validation
        if (typeof buf !== 'string') {
            throw new Error('buf must be a string');
        }
        
        // First check if this is already a box (contains box drawing characters)
        const isBox = /[‚îå‚îê‚îî‚îò‚îÇ‚îÄ‚ïî‚ïó‚ïö‚ïù‚ïë‚ïê]/.test(buf);
        
        if (isBox) {
            // If it's already a box, format each line individually
            const lines = buf.split('\n');
            let prefix;
            
            // Determine comment prefix based on style
            switch (style) {
            case 'shell':
            case 'python':
                prefix = '# ';
                break;
            case 'c':
                prefix = '// ';
                break;
            default:
                prefix = '// ';
            }
            
            // Return the commented box
            return lines.map(line => prefix + line).join('\n');
        } else {
            // If it's plain text, first wrap it based on maxLength
            let lines;
            if (maxLength && buf.length > maxLength) {
            lines = wrapText(buf, maxLength);
            } else {
            lines = [buf];
            }
            
            // Then format each line with the appropriate comment style
            switch (style) {
            case 'shell':
            case 'python':
                return lines.map(line => '# ' + line).join('\n');
            case 'c':
                return lines.map(line => '// ' + line).join('\n');
            default:
                return lines.map(line => '// ' + line).join('\n');
            }
        }
        }

    </script>
</body>
</html>