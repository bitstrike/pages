<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ASCII Box Generator 🎨</title>
<style>
body {
font-family: 'Arial', sans-serif;
background-color: #1e1e1e;
color: #e0e0e0;
margin: 20px;
display: flex;
flex-direction: column;
align-items: center;
}
h1, h2 {
color: #ff6f61;
}
form {
background-color: #2c2c2c;
padding: 20px;
border-radius: 10px;
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
}
label {
display: block;
margin-top: 10px;
color: #ffcc00;
}
textarea, input, select {
width: 95%;
padding: 10px;
margin-top: 5px;
border: 1px solid #444;
border-radius: 5px;
background-color: #3a3a3a;
color: #e0e0e0;
}
input[type="submit"] {
background-color: #ff6f61;
color: #1e1e1e;
border: none;
cursor: pointer;
font-size: 16px;
margin-top: 20px;
}
input[type="submit"]:hover {
background-color: #ff8f73;
}
.box {
font-family: monospace;
white-space: pre;
background-color: #3a3a3a;
padding: 15px;
border-radius: 5px;
margin-top: 20px;
}
.style-controls {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 15px;
margin-top: 10px;
}
</style>
</head>
<body>
<h1>ASCII Box Generator 🎨</h1>
<form id="boxForm">
<label for="message">📝 Message:</label>
<textarea id="message" name="message" rows="4" required></textarea>
<div class="style-controls">
<div>
<label for="boxStyle">🎨 Box Style:</label>
<select id="boxStyle" name="boxStyle">
<option value="1">Single Line</option>
<option value="2" selected>Double Line</option>
</select>
</div>
<div>
<label for="commentStyle">💬 Comment:</label>
<select id="commentStyle" name="commentStyle">
<option value="none">No Comment</option>
<option value="c">C code</option>
<option value="shell">Shell</option>
<option value="python">Python</option>
<option value="html">HTML</option>
</select>
</div>
</div>
<label for="maxLength">📏 Max Length:</label>
<input type="number" id="maxLength" name="maxLength" min="1">
<input type="submit" value="Generate Box 🚀">
</form>
<h2>Generated Box:</h2>
<div id="output" class="box"></div>

<script>
const messageInput = document.getElementById('message');

// Handle paste events
messageInput.addEventListener('paste', function(e) {
  e.preventDefault();
  const pastedText = e.clipboardData.getData('text/plain');
  const cleanText = pastedText.replace(/[\r\n\t]/g, ' ');
  const cursorPosition = this.selectionStart;
  const textBefore = this.value.substring(0, cursorPosition);
  const textAfter = this.value.substring(cursorPosition);
  this.value = textBefore + cleanText + textAfter;
  this.selectionStart = cursorPosition + cleanText.length;
  this.selectionEnd = this.selectionStart;
  this.focus();
});

document.getElementById('boxForm').addEventListener('submit', function(event) {
  event.preventDefault();
  const message = document.getElementById('message').value;
  const boxStyle = parseInt(document.getElementById('boxStyle').value);
  const commentStyle = document.getElementById('commentStyle').value;
  const maxLength = document.getElementById('maxLength').value !== '' ? parseInt(document.getElementById('maxLength').value) : null;
  
  // First create the box with proper line wrapping
  const box = createBox(message, boxStyle, maxLength);
  
  // Then format as comment if a comment style is selected
  const formattedOutput = formatComment(box, null, commentStyle);
  
  document.getElementById('output').textContent = formattedOutput;
});

// Add change event listener for commentStyle to update the output
document.getElementById('commentStyle').addEventListener('change', function() {
  const output = document.getElementById('output');
  if (output.textContent) {
    // Get the current message (not the formatted output)
    const message = document.getElementById('message').value;
    const boxStyle = parseInt(document.getElementById('boxStyle').value);
    const maxLength = document.getElementById('maxLength').value !== '' ? parseInt(document.getElementById('maxLength').value) : null;
    
    // Recreate the box
    const box = createBox(message, boxStyle, maxLength);
    
    // Format with the new comment style
    const formattedOutput = formatComment(box, null, this.value);
    output.textContent = formattedOutput;
  }
});

function createBox(origMessage, boxStyle = 2, maxLength = null) {
  let topBottom, corners, vertical;
  if (boxStyle === 1) {
    topBottom = '─';
    corners = '┌┐└┘';
    vertical = '│';
  } else {
    topBottom = '═';
    corners = '╔╗╚╝';
    vertical = '║';
  }
  
  // First wrap the text based on maxLength (if provided)
  let lines;
  if (maxLength && origMessage.length > maxLength) {
    lines = wrapText(origMessage, maxLength);
  } else {
    lines = [origMessage];
  }
  
  // Add padding around each line
  const paddedLines = lines.map(line => ' ' + line + ' ');
  
  // Find the width needed for the box (based on the longest line)
  const contentWidth = Math.max(...paddedLines.map(line => line.length));
  
  // Create the box elements
  const top = `${corners[0]}${topBottom.repeat(contentWidth)}${corners[1]}`;
  const bottom = `${corners[2]}${topBottom.repeat(contentWidth)}${corners[3]}░`;
  
  // Ensure all content lines are the same width for a uniform box
  const content = paddedLines.map(line => {
    const padded = line.padEnd(contentWidth);
    return `${vertical}${padded}${vertical}░`;
  });
  
  // Create the shadow
  const shadowWidth = contentWidth + 1;
  const shadow = "  " + "░".repeat(shadowWidth);
  
  // Return the complete box
  return [top, ...content, bottom, shadow].join('\n');
}

function wrapText(text, maxLength) {
  const words = text.split(' ');
  const lines = [];
  let tempLine = '';
  words.forEach(word => {
    if ((tempLine + word).length > maxLength) {
      lines.push(tempLine.trim());
      tempLine = '';
    }
    tempLine += (tempLine ? ' ' : '') + word;
  });
  lines.push(tempLine.trim());
  return lines;
}

// Function to format text as a comment in the specified style
function formatComment(buf, maxLength, style) {
  // Input validation
  if (typeof buf !== 'string') {
    throw new Error('buf must be a string');
  }
  
  // If no comment style is selected, return the buffer as is
  if (style === 'none') {
    return buf;
  }
  
  // First check if this is already a box (contains box drawing characters)
  const isBox = /[┌┐└┘│─╔╗╚╝║═]/.test(buf);
  
  if (isBox) {
    const lines = buf.split('\n');
    
    // HTML comments require special handling
    if (style === 'html') {
      // Start with comment opening
      let result = '<!--\n';
      
      // Add each line of the box
      lines.forEach(line => {
        result += line + '\n';
      });
      
      // End with comment closing
      result += '-->';
      return result;
    }
    
    // For other comment styles, prefix each line
    let prefix;
    switch (style) {
      case 'shell':
      case 'python':
        prefix = '# ';
        break;
      case 'c':
        prefix = '// ';
        break;
      default:
        prefix = '// ';
    }
    
    // Return the commented box
    return lines.map(line => prefix + line).join('\n');
  } else {
    // If it's plain text, first wrap it based on maxLength
    let lines;
    if (maxLength && buf.length > maxLength) {
      lines = wrapText(buf, maxLength);
    } else {
      lines = [buf];
    }
    
    // Then format based on comment style
    switch (style) {
      case 'html':
        return '<!--\n' + lines.join('\n') + '\n-->';
      case 'shell':
      case 'python':
        return lines.map(line => '# ' + line).join('\n');
      case 'c':
        return lines.map(line => '// ' + line).join('\n');
      default:
        return lines.map(line => '// ' + line).join('\n');
    }
  }
}
</script>
</body>
</html>