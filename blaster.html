<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Blaster</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
        }
        
        canvas {
            border: 2px solid #333;
            display: block;
            background: #000814;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            color: #0ff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #0ff;
        }
        
        #topRow {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        #countdown {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            color: #ff0;
            text-shadow: 0 0 20px #ff0;
            display: none;
            animation: pulse 1s infinite;
        }
        
        #countdown.critical {
            color: #f00;
            text-shadow: 0 0 20px #f00;
            animation: pulse 0.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }
        
        .hud-item {
            margin-bottom: 8px;
        }
        
        #score {
            font-size: 24px;
        }
        
        #shieldBar {
            width: 200px;
            height: 20px;
            background: #001a33;
            border: 2px solid #0066cc;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        #shieldFill {
            height: 100%;
            background: linear-gradient(90deg, #0099ff, #00ffff);
            width: 100%;
            transition: width 0.2s;
            box-shadow: 0 0 10px #0ff;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-size: 48px;
            text-shadow: 0 0 20px #f00;
            display: none;
        }
        
        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0f0;
            font-size: 48px;
            text-shadow: 0 0 20px #0f0;
            display: none;
            text-align: center;
        }
        
        #dockingHint {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0;
            font-size: 24px;
            text-shadow: 0 0 10px #ff0;
            display: none;
        }
        
        #powerUpIndicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(calc(-100% - 20px)); /* 20px to the left of center */
            color: #00bfff;
            font-size: 24px;
            text-shadow: 0 0 15px #00bfff;
            display: none;
            animation: blink 0.5s infinite;
        }
        
        #soundIndicator {
            position: absolute;
            top: 50px;
            right: 10px;
            color: #888;
            font-size: 20px;
            text-shadow: 0 0 5px #888;
        }
        
        #soundIndicator.muted {
            color: #f00;
            text-shadow: 0 0 5px #f00;
        }
        
        #pauseOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 64px;
            text-shadow: 0 0 30px #fff;
            display: none;
            z-index: 100;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #888;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div id="topRow">
                <div id="score" class="hud-item">SCORE: 0</div>
                <div id="level" class="hud-item">LEVEL: 1</div>
            </div>
            <div class="hud-item">
                <div>SHIELDS</div>
                <div id="shieldBar">
                    <div id="shieldFill"></div>
                </div>
            </div>
            <div id="bombCount" class="hud-item" style="color: #00f; display: none;">BOMBS: 0</div>
        </div>
        <div id="countdown"></div>
        <div id="powerUpIndicator">â—†â—†</div>
        <div id="soundIndicator">ðŸ”Š</div>
        <div id="pauseOverlay">PAUSED</div>
        <canvas id="gameCanvas"></canvas>
        <div id="gameOver">SHIP DESTROYED!</div>
        <div id="levelComplete">LEVEL COMPLETE!<br><span style="font-size: 24px;">Next level starting...</span></div>
        <div id="dockingHint">âš  STATION AHEAD - DOCK TO COMPLETE LEVEL âš </div>
        <div id="instructions">
            Arrow Keys: Move | Spacebar: Fire | B: Bomb (Lv4+) | S: Toggle Sound | P: Pause
        </div>
        <audio id="dockingStationSound" src="docking-station.mp3" loop></audio>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = 1200;
        canvas.height = 600;
        
        // Game Constants
        const CONSTANTS = {
            // Frame rate
            TARGET_FPS: 60,
            TARGET_FRAME_TIME: 1000 / 60, // 16.67ms
            
            // Canvas
            CANVAS_WIDTH: 1200,
            CANVAS_HEIGHT: 600,
            
            // Ship
            SHIP_WIDTH: 40,
            SHIP_HEIGHT: 20,
            SHIP_MAX_SHIELDS: 50,
            SHIP_SPEED: 5,
            SHIP_START_X: 200,
            SHIP_START_Y: 300,
            
            // Scroll
            SCROLL_SPEED: 3, // Fixed across all levels
            
            // Lasers
            PLAYER_LASER_SPEED: 15,
            PLAYER_LASER_WIDTH: 20,
            PLAYER_LASER_HEIGHT: 3,
            ENEMY_LASER_WIDTH: 15,
            ENEMY_LASER_HEIGHT: 3,
            
            // Dual shot
            DUAL_SHOT_DURATION_FRAMES: 600, // 10 seconds at 60fps
            DUAL_SHOT_ANGLE: 0.2,
            DUAL_SHOT_BONUS: 25,
            
            // Obstacles
            OBSTACLE_MIN_SIZE: 20,
            OBSTACLE_MAX_SIZE: 50,
            OBSTACLE_SPAWN_INTERVAL_FRAMES: 60, // 1 second
            OBSTACLE_POINTS: 10,
            OBSTACLE_DAMAGE: 5,
            
            // Power-ups
            POWERUP_SIZE: 15,
            POWERUP_SPAWN_FRACTION: 0.5, // Midpoint of level
            BOMB_POWERUP_SIZE: 12,
            BOMB_POWERUP_SPAWN_MULTIPLIER: 4, // Bombs spawn at 3x cannon spawn interval
            BOMB_POWERUP_COUNT: 2,
            BOMB_POWERUP_BONUS: 25,
            
            // Bombs
            BOMB_SIZE: 8,
            BOMB_SPEED: 6,
            BOMB_POINTS: 50,
            
            // Cannons
            CANNON_WIDTH: 30,
            CANNON_HEIGHT: 40,
            CANNON_BARREL_LENGTH: 25,
            CANNON_POINTS: 50,
            CANNON_BURST_SPREAD_DEGREES: 10,
            
            // Station
            STATION_WIDTH: 150,
            STATION_HEIGHT: 200,
            DOCKING_BAY_WIDTH: 50,
            DOCKING_BAY_HEIGHT: 30,
            DOCKING_COUNTDOWN_SECONDS: 10,
            DOCKING_TIMER_FRAMES: 180, // 3 seconds
            DOCKING_CRITICAL_THRESHOLD: 3, // seconds
            
            // Terrain
            TERRAIN_SEGMENT_WIDTH: 20,
            TERRAIN_MIN_HEIGHT: 50,
            TERRAIN_MAX_HEIGHT: 200,
            TERRAIN_SAFE_TOP_AREA: 250,
            TERRAIN_COLLISION_DAMAGE: 2,
            
            // Shield Regeneration
            SHIELD_REGEN_DELAY_SECONDS: 3,
            SHIELD_REGEN_RATE_PER_SECOND: 1 / 3, // 1 shield point every 3 seconds
            SHIELD_REGEN_PER_OBJECT: 2, // Bonus shields for destroying objects
            
            // Stars
            STAR_COUNT: 100,
            STAR_PARALLAX_FACTOR: 0.1,
            
            // Timers
            RESPAWN_TIMER_FRAMES: 120, // 2 seconds
            LEVEL_COMPLETE_TIMER_FRAMES: 180, // 3 seconds
            
            // Damage
            ENEMY_LASER_DAMAGE: 3,
            
            // Enemy laser burst
            ENEMY_BURST_SPREAD_RADIANS: (10 * Math.PI) / 180
        };
        
        // Level Configuration
        const LEVEL_CONFIG = {
            1: { 
                durationSeconds: 30,
                cannonFireRateSeconds: 2.0,
                cannonSpawnRateSeconds: 3.0,
                enemyLaserSpeed: 8,
                enemyBurstCount: 1,
                levelCompleteBonus: 100
            },
            2: { 
                durationSeconds: 45,
                cannonFireRateSeconds: 1.8,
                cannonSpawnRateSeconds: 2.5,
                enemyLaserSpeed: 9,
                enemyBurstCount: 1,
                levelCompleteBonus: 200
            },
            3: { 
                durationSeconds: 60,
                cannonFireRateSeconds: 1.5,
                cannonSpawnRateSeconds: 2.0,
                enemyLaserSpeed: 10,
                enemyBurstCount: 1,
                levelCompleteBonus: 300
            },
            4: { 
                durationSeconds: 75,
                cannonFireRateSeconds: 1.2,
                cannonSpawnRateSeconds: 1.8,
                enemyLaserSpeed: 11,
                enemyBurstCount: 2,
                levelCompleteBonus: 400
            },
            5: { 
                durationSeconds: 90,
                cannonFireRateSeconds: 1.0,
                cannonSpawnRateSeconds: 1.5,
                enemyLaserSpeed: 12,
                enemyBurstCount: 2,
                levelCompleteBonus: 500
            }
        };
        
        // Visual Theme Palettes
        const THEME_PALETTES = [
            {
                name: 'desert',
                asteroidPalette: {
                    baseHue: 30,        // Orange-brown
                    hueVariation: 20,
                    saturation: [45, 65],
                    lightness: [40, 55]
                },
                terrainFill: { h: 35, s: 55, l: 25 },
                terrainStroke: { h: 40, s: 60, l: 35 },
                starTint: { h: 25, s: 80, l: 70 }  // Orange/red stars
            },
            {
                name: 'alien',
                asteroidPalette: {
                    baseHue: 280,       // Purple/magenta (cyberpunk)
                    hueVariation: 30,
                    saturation: [60, 80],
                    lightness: [35, 50]
                },
                terrainFill: { h: 290, s: 45, l: 20 },
                terrainStroke: { h: 300, s: 55, l: 30 },
                starTint: { h: 280, s: 70, l: 75 }  // Purple/pink stars
            },
            {
                name: 'volcanic',
                asteroidPalette: {
                    baseHue: 0,         // Red
                    hueVariation: 15,
                    saturation: [40, 60],
                    lightness: [30, 45]
                },
                terrainFill: { h: 0, s: 20, l: 18 },
                terrainStroke: { h: 10, s: 40, l: 25 },
                starTint: { h: 15, s: 85, l: 65 }  // Red/orange stars
            },
            {
                name: 'stormy',
                asteroidPalette: {
                    baseHue: 210,       // Blue
                    hueVariation: 25,
                    saturation: [35, 55],
                    lightness: [35, 50]
                },
                terrainFill: { h: 215, s: 30, l: 22 },
                terrainStroke: { h: 220, s: 40, l: 32 },
                starTint: { h: 200, s: 40, l: 85 }  // Blue/white stars
            }
        ];
        
        function getCurrentTheme(level) {
            const themeCount = THEME_PALETTES.length;
            
            if (level <= themeCount) {
                return THEME_PALETTES[level - 1];
            }
            
            // Procedural: interpolate between themes
            const cyclePosition = (level - 1) % themeCount;
            const nextCycle = (cyclePosition + 1) % themeCount;
            const blendFactor = ((level - 1) / themeCount) % 1;
            
            const theme1 = THEME_PALETTES[cyclePosition];
            const theme2 = THEME_PALETTES[nextCycle];
            
            return interpolateThemes(theme1, theme2, blendFactor);
        }
        
        function interpolateThemes(theme1, theme2, t) {
            const lerp = (a, b, t) => a + (b - a) * t;
            const lerpHue = (h1, h2, t) => {
                // Handle hue wrapping (0-360)
                let diff = h2 - h1;
                if (diff > 180) diff -= 360;
                if (diff < -180) diff += 360;
                return (h1 + diff * t + 360) % 360;
            };
            
            return {
                name: `${theme1.name}-${theme2.name}`,
                asteroidPalette: {
                    baseHue: lerpHue(theme1.asteroidPalette.baseHue, theme2.asteroidPalette.baseHue, t),
                    hueVariation: lerp(theme1.asteroidPalette.hueVariation, theme2.asteroidPalette.hueVariation, t),
                    saturation: [
                        lerp(theme1.asteroidPalette.saturation[0], theme2.asteroidPalette.saturation[0], t),
                        lerp(theme1.asteroidPalette.saturation[1], theme2.asteroidPalette.saturation[1], t)
                    ],
                    lightness: [
                        lerp(theme1.asteroidPalette.lightness[0], theme2.asteroidPalette.lightness[0], t),
                        lerp(theme1.asteroidPalette.lightness[1], theme2.asteroidPalette.lightness[1], t)
                    ]
                },
                terrainFill: {
                    h: lerpHue(theme1.terrainFill.h, theme2.terrainFill.h, t),
                    s: lerp(theme1.terrainFill.s, theme2.terrainFill.s, t),
                    l: lerp(theme1.terrainFill.l, theme2.terrainFill.l, t)
                },
                terrainStroke: {
                    h: lerpHue(theme1.terrainStroke.h, theme2.terrainStroke.h, t),
                    s: lerp(theme1.terrainStroke.s, theme2.terrainStroke.s, t),
                    l: lerp(theme1.terrainStroke.l, theme2.terrainStroke.l, t)
                },
                starTint: {
                    h: lerpHue(theme1.starTint.h, theme2.starTint.h, t),
                    s: lerp(theme1.starTint.s, theme2.starTint.s, t),
                    l: lerp(theme1.starTint.l, theme2.starTint.l, t)
                }
            };
        }
        
        function generateAsteroidColor(theme) {
            const palette = theme.asteroidPalette;
            const hue = palette.baseHue + (Math.random() - 0.5) * 2 * palette.hueVariation;
            const sat = palette.saturation[0] + Math.random() * (palette.saturation[1] - palette.saturation[0]);
            const light = palette.lightness[0] + Math.random() * (palette.lightness[1] - palette.lightness[0]);
            
            const fillColor = `hsl(${hue}, ${sat}%, ${light}%)`;
            const strokeColor = `hsl(${hue}, ${sat + 10}%, ${light - 10}%)`;
            
            return { fillColor, strokeColor };
        }
        
        // Audio context for sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const dockingStationAudio = document.getElementById('dockingStationSound');
        
        // Sound effects using Web Audio API
        function playPewPew() {
            if (!game.soundEnabled) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        function playExplosion() {
            if (!game.soundEnabled) return;
            
            const bufferSize = audioContext.sampleRate * 0.5;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioContext.sampleRate * 0.1));
            }
            
            const noise = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            noise.buffer = buffer;
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);
            
            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            noise.start(audioContext.currentTime);
            noise.stop(audioContext.currentTime + 0.3);
        }
        
        function playDockingSuccess() {
            if (!game.soundEnabled) return;
            
            // Play ascending tones for success
            for (let i = 0; i < 3; i++) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const startTime = audioContext.currentTime + i * 0.1;
                oscillator.frequency.setValueAtTime(400 + i * 200, startTime);
                
                gainNode.gain.setValueAtTime(0.2, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.2);
            }
        }
        
        function playDockingReady() {
            if (!game.soundEnabled) return;
            
            // Play single ready tone
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.4);
        }
        
        function playShieldsFullTone() {
            if (!game.soundEnabled) return;
            
            // Play dual "doot-doot" tone for full shields
            for (let i = 0; i < 2; i++) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const startTime = audioContext.currentTime + i * 0.15;
                oscillator.frequency.setValueAtTime(600, startTime);
                
                gainNode.gain.setValueAtTime(0.25, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.1);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.1);
            }
        }
        
        function activateDualShot() {
            game.dualShotActive = true;
            game.dualShotTimer = CONSTANTS.DUAL_SHOT_DURATION_FRAMES;
            game.score += CONSTANTS.DUAL_SHOT_BONUS;
            updateScore();
            
            // Show power-up indicator
            document.getElementById('powerUpIndicator').style.display = 'block';
            
            // Play power-up sound
            if (game.soundEnabled) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            }
        }
        
        // Game state
        let lastTime = 0;
        
        const game = {
            score: 0,
            terrainOffset: 0,
            isGameOver: false,
            respawnTimer: 0,
            level: 1,
            levelElapsedMs: 0,
            levelDurationMs: 0,
            isDocked: false,
            dockingTimer: 0,
            countdownActive: false,
            countdownMs: 0,
            dualShotActive: false,
            dualShotTimer: 0,
            powerUpSpawned: false,
            soundEnabled: true,
            isPaused: false,
            bombCount: 0,
            bombPowerUpTimer: 0
        };
        
        // Ship
        const ship = {
            x: CONSTANTS.SHIP_START_X,
            y: CONSTANTS.SHIP_START_Y,
            width: CONSTANTS.SHIP_WIDTH,
            height: CONSTANTS.SHIP_HEIGHT,
            vx: 0,
            vy: 0,
            shields: CONSTANTS.SHIP_MAX_SHIELDS,
            maxShields: CONSTANTS.SHIP_MAX_SHIELDS,
            acceleration: 0,
            lives: 3,
            timeSinceLastDamage: 0,
            shieldsFullSoundPlayed: false
        };
        
        // Controls
        const keys = {};
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // Spacebar to fire
            if (e.key === ' ' && !game.isGameOver && !game.isPaused) {
                e.preventDefault();
                fireLaser();
            }
            
            // 's' key to toggle sound
            if (e.key === 's' || e.key === 'S') {
                game.soundEnabled = !game.soundEnabled;
                updateSoundIndicator();
            }
            
            // 'p' key to toggle pause
            if (e.key === 'p' || e.key === 'P') {
                game.isPaused = !game.isPaused;
                updatePauseDisplay();
            }
            
            // 'b' key to fire bomb
            if (e.key === 'b' || e.key === 'B') {
                if (!game.isPaused && !game.isGameOver && game.bombCount > 0) {
                    fireBomb();
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // Lasers
        const lasers = [];
        
        function fireLaser() {
            if (game.dualShotActive) {
                // Fire two lasers in a fanned pattern
                lasers.push({
                    x: ship.x + ship.width,
                    y: ship.y + ship.height / 2,
                    width: CONSTANTS.PLAYER_LASER_WIDTH,
                    height: CONSTANTS.PLAYER_LASER_HEIGHT,
                    speed: CONSTANTS.PLAYER_LASER_SPEED,
                    angle: -CONSTANTS.DUAL_SHOT_ANGLE
                });
                lasers.push({
                    x: ship.x + ship.width,
                    y: ship.y + ship.height / 2,
                    width: CONSTANTS.PLAYER_LASER_WIDTH,
                    height: CONSTANTS.PLAYER_LASER_HEIGHT,
                    speed: CONSTANTS.PLAYER_LASER_SPEED,
                    angle: CONSTANTS.DUAL_SHOT_ANGLE
                });
            } else {
                // Single straight laser
                lasers.push({
                    x: ship.x + ship.width,
                    y: ship.y + ship.height / 2,
                    width: CONSTANTS.PLAYER_LASER_WIDTH,
                    height: CONSTANTS.PLAYER_LASER_HEIGHT,
                    speed: CONSTANTS.PLAYER_LASER_SPEED,
                    angle: 0
                });
            }
            playPewPew();
        }
        
        // Obstacles
        const obstacles = [];
        let obstacleSpawnTimer = 0;
        
        // Power-ups
        const powerUps = [];
        const bombPowerUps = []; // Red dot power-ups for bombs
        const bombs = []; // Active heat-seeking bombs
        
        // Laser Cannons (level 3+)
        const cannons = [];
        let cannonSpawnTimer = 0;
        const enemyLasers = [];
        
        function spawnCannon() {
            // Find terrain height at a random x position
            const spawnX = canvas.width + 50; // Start off-screen right
            
            const config = getCurrentLevelConfig();
            
            cannons.push({
                x: spawnX,
                y: 0, // Will be set based on terrain
                width: CONSTANTS.CANNON_WIDTH,
                height: CONSTANTS.CANNON_HEIGHT,
                barrelAngle: 0,
                fireTimer: config.cannonFireRateSeconds * CONSTANTS.TARGET_FPS,
                destroyed: false
            });
        }
        
        function getCurrentLevelConfig() {
            // Get config for current level, or use highest level config if beyond defined levels
            const maxLevel = Math.max(...Object.keys(LEVEL_CONFIG).map(Number));
            const level = Math.min(game.level, maxLevel);
            return LEVEL_CONFIG[level];
        }
        
        function getTerrainHeightAt(x) {
            // Find the terrain height at a given x position
            for (let i = 0; i < terrain.points.length - 1; i++) {
                const p1 = terrain.points[i];
                const p2 = terrain.points[i + 1];
                
                if (x >= p1.x && x <= p2.x) {
                    // Linear interpolation
                    const t = (x - p1.x) / (p2.x - p1.x);
                    return p1.y + (p2.y - p1.y) * t;
                }
            }
            return canvas.height - 100; // Default
        }
        
        function fireCannonLaser(cannon) {
            // Calculate direction to ship
            const dx = ship.x + ship.width / 2 - cannon.x;
            const dy = ship.y + ship.height / 2 - cannon.y;
            const baseAngle = Math.atan2(dy, dx);
            
            const config = getCurrentLevelConfig();
            
            // Level 4+: Fire burst with spread
            if (config.enemyBurstCount > 1) {
                const spreadAngle = CONSTANTS.ENEMY_BURST_SPREAD_RADIANS;
                
                // First shot - angled up
                enemyLasers.push({
                    x: cannon.x,
                    y: cannon.y - 15,
                    width: CONSTANTS.ENEMY_LASER_WIDTH,
                    height: CONSTANTS.ENEMY_LASER_HEIGHT,
                    speed: config.enemyLaserSpeed,
                    angle: baseAngle - spreadAngle / 2
                });
                
                // Second shot - angled down
                enemyLasers.push({
                    x: cannon.x,
                    y: cannon.y - 15,
                    width: CONSTANTS.ENEMY_LASER_WIDTH,
                    height: CONSTANTS.ENEMY_LASER_HEIGHT,
                    speed: config.enemyLaserSpeed,
                    angle: baseAngle + spreadAngle / 2
                });
            } else {
                // Single shot
                enemyLasers.push({
                    x: cannon.x,
                    y: cannon.y - 15,
                    width: CONSTANTS.ENEMY_LASER_WIDTH,
                    height: CONSTANTS.ENEMY_LASER_HEIGHT,
                    speed: config.enemyLaserSpeed,
                    angle: baseAngle
                });
            }
            
            // Play enemy laser sound
            if (game.soundEnabled) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.15);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
            }
        }
        
        function spawnObstacle() {
            const size = CONSTANTS.OBSTACLE_MIN_SIZE + Math.random() * (CONSTANTS.OBSTACLE_MAX_SIZE - CONSTANTS.OBSTACLE_MIN_SIZE);
            // Spawn only in the safe area above terrain (leaving margin)
            const safeTopArea = canvas.height - CONSTANTS.TERRAIN_SAFE_TOP_AREA;
            
            const theme = getCurrentTheme(game.level);
            const colors = generateAsteroidColor(theme);
            
            obstacles.push({
                x: canvas.width,
                y: 50 + Math.random() * safeTopArea,
                width: size,
                height: size,
                destroyed: false,
                fillColor: colors.fillColor,
                strokeColor: colors.strokeColor
            });
        }
        
        function spawnPowerUp() {
            // Spawn in safe area above terrain
            const safeTopArea = canvas.height - CONSTANTS.TERRAIN_SAFE_TOP_AREA;
            powerUps.push({
                x: canvas.width,
                y: 50 + Math.random() * safeTopArea,
                size: CONSTANTS.POWERUP_SIZE,
                destroyed: false,
                rotation: 0
            });
        }
        
        function spawnBombPowerUp() {
            // Spawn red dot power-up in safe area
            const safeTopArea = canvas.height - CONSTANTS.TERRAIN_SAFE_TOP_AREA;
            bombPowerUps.push({
                x: canvas.width,
                y: 50 + Math.random() * safeTopArea,
                size: CONSTANTS.BOMB_POWERUP_SIZE,
                destroyed: false
            });
        }
        
        function fireBomb() {
            if (game.bombCount <= 0) return;
            
            game.bombCount--;
            updateBombCount();
            
            // Find nearest ground target (cannon) within view
            let nearestTarget = null;
            let nearestDist = Infinity;
            
            for (let cannon of cannons) {
                if (!cannon.destroyed && cannon.x >= 0 && cannon.x <= canvas.width) {
                    const dist = Math.sqrt(
                        Math.pow(cannon.x - ship.x, 2) + 
                        Math.pow(cannon.y - ship.y, 2)
                    );
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestTarget = cannon;
                    }
                }
            }
            
            // Create bomb
            bombs.push({
                x: ship.x + ship.width,
                y: ship.y + ship.height / 2,
                size: CONSTANTS.BOMB_SIZE,
                speed: CONSTANTS.BOMB_SPEED,
                target: nearestTarget,
                vx: 0,
                vy: 0
            });
            
            // Play bomb launch sound
            if (game.soundEnabled) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            }
        }
        
        // Space Station
        const station = {
            x: 0,
            y: 0,
            width: CONSTANTS.STATION_WIDTH,
            height: CONSTANTS.STATION_HEIGHT,
            dockingBay: {
                x: 0,
                y: 0,
                width: CONSTANTS.DOCKING_BAY_WIDTH,
                height: CONSTANTS.DOCKING_BAY_HEIGHT
            },
            active: false,
            isVisible: false
        };
        
        function spawnStation() {
            station.y = canvas.height / 2 - station.height / 2;
            station.x = canvas.width + 200; // Start off-screen right
            
            // Docking bay is in the middle left side of station
            station.dockingBay.x = station.x;
            station.dockingBay.y = station.y + station.height / 2 - station.dockingBay.height / 2;
            
            station.active = true;
            station.isVisible = false;
            
            // Start playing docking station approach sound
            if (game.soundEnabled) {
                dockingStationAudio.currentTime = 0;
                dockingStationAudio.volume = 0.5;
                dockingStationAudio.play().catch(e => console.log('Audio play failed:', e));
            }
        }
        
        function updateStation() {
            if (station.active) {
                // Move station slowly into view
                if (!station.isVisible && station.x > canvas.width - station.width - 100) {
                    station.x -= 1;
                    if (station.x <= canvas.width - station.width - 100) {
                        station.isVisible = true;
                        
                        // Stop docking station sound and play ready tone
                        dockingStationAudio.pause();
                        dockingStationAudio.currentTime = 0;
                        playDockingReady();
                        
                        // Start countdown now that station is visible
                        startCountdown();
                    }
                }
                
                // Update docking bay position
                station.dockingBay.x = station.x;
                station.dockingBay.y = station.y + station.height / 2 - station.dockingBay.height / 2;
            }
        }
        
        function checkDocking() {
            if (!station.active || !station.isVisible) return false;
            
            // Check if ship center is within docking bay
            const dockBox = station.dockingBay;
            const shipCenterX = ship.x + ship.width / 2;
            const shipCenterY = ship.y + ship.height / 2;
            
            // Ship center must be inside the docking bay rectangle
            return shipCenterX > dockBox.x && 
                   shipCenterX < dockBox.x + dockBox.width &&
                   shipCenterY > dockBox.y && 
                   shipCenterY < dockBox.y + dockBox.height;
        }
        
        // Starfield
        const stars = [];
        function initStars() {
            for (let i = 0; i < CONSTANTS.STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: (i % 3) * 0.5 + 0.5,
                    brightness: 0.7 + Math.random() * 0.3 // Vary brightness
                });
            }
        }
        initStars();
        
        // Terrain generation using Perlin-like noise
        const terrain = {
            points: [],
            segmentWidth: CONSTANTS.TERRAIN_SEGMENT_WIDTH
        };
        
        function generateTerrain() {
            terrain.points = [];
            let y = canvas.height - 100;
            
            for (let x = 0; x < canvas.width + 200; x += terrain.segmentWidth) {
                // Random walk with smoothing
                y += (Math.random() - 0.5) * 40;
                y = Math.max(canvas.height - CONSTANTS.TERRAIN_MAX_HEIGHT, Math.min(canvas.height - CONSTANTS.TERRAIN_MIN_HEIGHT, y));
                
                terrain.points.push({ x, y });
            }
        }
        
        generateTerrain();
        
        // Collision detection
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        function isShipInTerrain() {
            // Check if ship is below any terrain point
            const shipRight = ship.x + ship.width;
            
            for (let i = 0; i < terrain.points.length - 1; i++) {
                const p1 = terrain.points[i];
                const p2 = terrain.points[i + 1];
                
                if (ship.x < p2.x && shipRight > p1.x) {
                    // Linear interpolation between points
                    const t = (ship.x + ship.width / 2 - p1.x) / (p2.x - p1.x);
                    const terrainY = p1.y + (p2.y - p1.y) * t;
                    
                    if (ship.y + ship.height > terrainY) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Update function
        function update(deltaTime) {
            if (game.isPaused) {
                return; // Don't update anything when paused
            }
            
            if (game.isGameOver) {
                game.respawnTimer += deltaTime;
                if (game.respawnTimer > CONSTANTS.RESPAWN_TIMER_FRAMES) {
                    respawnShip();
                }
                return;
            }
            
            if (game.isDocked) {
                game.dockingTimer += deltaTime;
                if (game.dockingTimer > CONSTANTS.DOCKING_TIMER_FRAMES) {
                    nextLevel();
                }
                return;
            }
            
            // Track level elapsed time
            game.levelElapsedMs += (deltaTime / CONSTANTS.TARGET_FPS) * 1000;
            
            // Spawn station when level duration reached
            if (game.levelElapsedMs >= game.levelDurationMs && !station.active) {
                spawnStation();
                document.getElementById('dockingHint').style.display = 'block';
            }
            
            // Update station
            updateStation();
            
            // Update countdown timer
            if (game.countdownActive) {
                game.countdownMs -= (deltaTime / CONSTANTS.TARGET_FPS) * 1000;
                updateCountdownDisplay();
                
                // Timer ran out!
                if (game.countdownMs <= 0) {
                    timeoutDocking();
                }
            }
            
            // Check for docking
            if (checkDocking()) {
                completeDocking();
            }
            
            // Ship movement
            ship.vx = 0;
            ship.vy = 0;
            ship.acceleration = 0;
            
            if (keys['ArrowLeft']) {
                ship.vx = -CONSTANTS.SHIP_SPEED;
            }
            if (keys['ArrowRight']) {
                ship.vx = CONSTANTS.SHIP_SPEED;
                ship.acceleration = 1;
            }
            if (keys['ArrowUp']) {
                ship.vy = -CONSTANTS.SHIP_SPEED;
            }
            if (keys['ArrowDown']) {
                ship.vy = CONSTANTS.SHIP_SPEED;
            }
            
            // Update ship position
            const oldY = ship.y;
            ship.x += ship.vx * deltaTime;
            ship.y += ship.vy * deltaTime;
            
            // Boundaries
            ship.x = Math.max(0, Math.min(canvas.width - ship.width, ship.x));
            ship.y = Math.max(0, Math.min(canvas.height - ship.height, ship.y));
            
            // Check terrain collision
            if (isShipInTerrain()) {
                ship.y = oldY; // Prevent moving into terrain
                
                // If still in terrain, push up
                while (isShipInTerrain() && ship.y > 0) {
                    ship.y--;
                }
                
                // Damage shields on terrain collision
                damageShip(CONSTANTS.TERRAIN_COLLISION_DAMAGE);
            }
            
            // Shield regeneration
            ship.timeSinceLastDamage += (deltaTime / CONSTANTS.TARGET_FPS);
            
            if (ship.timeSinceLastDamage >= CONSTANTS.SHIELD_REGEN_DELAY_SECONDS) {
                if (ship.shields < ship.maxShields) {
                    const regenAmount = (CONSTANTS.SHIELD_REGEN_RATE_PER_SECOND * deltaTime) / CONSTANTS.TARGET_FPS;
                    const wasNotFull = ship.shields < ship.maxShields;
                    ship.shields = Math.min(ship.maxShields, ship.shields + regenAmount);
                    updateShields();
                    
                    // Play sound when shields reach 100%
                    if (wasNotFull && ship.shields >= ship.maxShields && !ship.shieldsFullSoundPlayed) {
                        playShieldsFullTone();
                        ship.shieldsFullSoundPlayed = true;
                    }
                }
            }
            
            // Update lasers
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                laser.x += laser.speed * deltaTime;
                laser.y += laser.speed * Math.sin(laser.angle) * deltaTime;
                
                // Remove off-screen lasers
                if (laser.x > canvas.width || laser.y < 0 || laser.y > canvas.height) {
                    lasers.splice(i, 1);
                }
            }
            
            // Update dual-shot timer
            if (game.dualShotActive) {
                game.dualShotTimer -= deltaTime;
                if (game.dualShotTimer <= 0) {
                    game.dualShotActive = false;
                    document.getElementById('powerUpIndicator').style.display = 'none';
                }
            }
            
            // Spawn power-up once per level at midpoint
            if (!game.powerUpSpawned && game.levelElapsedMs >= game.levelDurationMs * CONSTANTS.POWERUP_SPAWN_FRACTION) {
                spawnPowerUp();
                game.powerUpSpawned = true;
            }
            
            // Update power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.x -= CONSTANTS.SCROLL_SPEED * deltaTime;
                powerUp.rotation += 0.05 * deltaTime;
                
                // Check laser collisions with power-ups
                for (let j = lasers.length - 1; j >= 0; j--) {
                    const laser = lasers[j];
                    const distance = Math.sqrt(
                        Math.pow(laser.x - powerUp.x, 2) + 
                        Math.pow(laser.y - powerUp.y, 2)
                    );
                    
                    if (distance < powerUp.size) {
                        powerUp.destroyed = true;
                        lasers.splice(j, 1);
                        activateDualShot();
                        break;
                    }
                }
                
                // Check ship collision with power-ups
                if (!powerUp.destroyed) {
                    const shipCenterX = ship.x + ship.width / 2;
                    const shipCenterY = ship.y + ship.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(shipCenterX - powerUp.x, 2) + 
                        Math.pow(shipCenterY - powerUp.y, 2)
                    );
                    
                    if (distance < powerUp.size + 15) { // Ship collision radius
                        powerUp.destroyed = true;
                        activateDualShot();
                    }
                }
                
                // Remove off-screen or destroyed power-ups
                if (powerUp.x + powerUp.size < 0 || powerUp.destroyed) {
                    powerUps.splice(i, 1);
                }
            }
            
            // Spawn bomb power-up periodically at 3x cannon spawn rate (level 4+)
            if (game.level >= 4) {
                const config = getCurrentLevelConfig();
                const bombSpawnInterval = config.cannonSpawnRateSeconds * CONSTANTS.BOMB_POWERUP_SPAWN_MULTIPLIER * CONSTANTS.TARGET_FPS;
                
                game.bombPowerUpTimer += deltaTime;
                if (game.bombPowerUpTimer >= bombSpawnInterval) {
                    spawnBombPowerUp();
                    game.bombPowerUpTimer = 0;
                }
            }
            
            // Update bomb power-ups
            for (let i = bombPowerUps.length - 1; i >= 0; i--) {
                const bombPU = bombPowerUps[i];
                bombPU.x -= CONSTANTS.SCROLL_SPEED * deltaTime;
                
                // Check laser collisions with bomb power-ups
                for (let j = lasers.length - 1; j >= 0; j--) {
                    const laser = lasers[j];
                    const distance = Math.sqrt(
                        Math.pow(laser.x - bombPU.x, 2) + 
                        Math.pow(laser.y - bombPU.y, 2)
                    );
                    
                    if (distance < bombPU.size) {
                        bombPU.destroyed = true;
                        lasers.splice(j, 1);
                        game.bombCount += CONSTANTS.BOMB_POWERUP_COUNT;
                        game.score += CONSTANTS.BOMB_POWERUP_BONUS;
                        updateScore();
                        updateBombCount();
                        
                        // Play power-up sound
                        if (game.soundEnabled) {
                            const oscillator = audioContext.createOscillator();
                            const gainNode = audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(250, audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.2);
                            
                            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                            
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.2);
                        }
                        break;
                    }
                }
                
                // Check ship collision with bomb power-ups
                if (!bombPU.destroyed) {
                    const shipCenterX = ship.x + ship.width / 2;
                    const shipCenterY = ship.y + ship.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(shipCenterX - bombPU.x, 2) + 
                        Math.pow(shipCenterY - bombPU.y, 2)
                    );
                    
                    if (distance < bombPU.size + 15) {
                        bombPU.destroyed = true;
                        game.bombCount += CONSTANTS.BOMB_POWERUP_COUNT;
                        game.score += CONSTANTS.BOMB_POWERUP_BONUS;
                        updateScore();
                        updateBombCount();
                        
                        // Play power-up sound
                        if (game.soundEnabled) {
                            const oscillator = audioContext.createOscillator();
                            const gainNode = audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(250, audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.2);
                            
                            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                            
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.2);
                        }
                    }
                }
                
                // Remove off-screen or destroyed bomb power-ups
                if (bombPU.x + bombPU.size < 0 || bombPU.destroyed) {
                    bombPowerUps.splice(i, 1);
                }
            }
            
            // Update bombs
            for (let i = bombs.length - 1; i >= 0; i--) {
                const bomb = bombs[i];
                
                // If target is destroyed or doesn't exist, try to find a new target
                if (!bomb.target || bomb.target.destroyed) {
                    // Find nearest cannon within view
                    let nearestTarget = null;
                    let nearestDist = Infinity;
                    
                    for (let cannon of cannons) {
                        if (!cannon.destroyed && cannon.x >= 0 && cannon.x <= canvas.width) {
                            const dist = Math.sqrt(
                                Math.pow(cannon.x - bomb.x, 2) + 
                                Math.pow(cannon.y - bomb.y, 2)
                            );
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestTarget = cannon;
                            }
                        }
                    }
                    
                    bomb.target = nearestTarget;
                }
                
                // If target exists and not destroyed, home in on it
                if (bomb.target && !bomb.target.destroyed) {
                    const dx = bomb.target.x - bomb.x;
                    const dy = bomb.target.y - bomb.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Normalize and apply speed
                    bomb.vx = (dx / dist) * bomb.speed;
                    bomb.vy = (dy / dist) * bomb.speed;
                    
                    // Check if hit target
                    if (dist < 20) {
                        bomb.target.destroyed = true;
                        bombs.splice(i, 1);
                        game.score += CONSTANTS.BOMB_POINTS;
                        updateScore();
                        playExplosion();
                        regenerateShieldsFromDestruction();
                        continue;
                    }
                } else {
                    // No target available, just move forward
                    bomb.vx = bomb.speed;
                    bomb.vy = 0;
                }
                
                bomb.x += bomb.vx * deltaTime;
                bomb.y += bomb.vy * deltaTime;
                
                // Remove off-screen bombs
                if (bomb.x < 0 || bomb.x > canvas.width || bomb.y < 0 || bomb.y > canvas.height) {
                    bombs.splice(i, 1);
                }
            }
            
            // Update laser cannons (level 3+)
            if (game.level >= 3) {
                const config = getCurrentLevelConfig();
                
                // Spawn cannon if none active and timer ready
                cannonSpawnTimer += deltaTime;
                const maxCannons = 1;
                const spawnInterval = config.cannonSpawnRateSeconds * CONSTANTS.TARGET_FPS;
                
                if (cannons.length < maxCannons && cannonSpawnTimer > spawnInterval) {
                    spawnCannon();
                    cannonSpawnTimer = 0;
                }
                
                // Update cannons
                for (let i = cannons.length - 1; i >= 0; i--) {
                    const cannon = cannons[i];
                    cannon.x -= CONSTANTS.SCROLL_SPEED * deltaTime;
                    
                    // Update cannon position to match terrain
                    cannon.y = getTerrainHeightAt(cannon.x);
                    
                    // Aim barrel at ship
                    const dx = ship.x + ship.width / 2 - cannon.x;
                    const dy = ship.y + ship.height / 2 - (cannon.y - cannon.height / 2);
                    cannon.barrelAngle = Math.atan2(dy, dx);
                    
                    // Fire at ship
                    cannon.fireTimer -= deltaTime;
                    if (cannon.fireTimer <= 0 && !cannon.destroyed) {
                        fireCannonLaser(cannon);
                        cannon.fireTimer = config.cannonFireRateSeconds * CONSTANTS.TARGET_FPS;
                    }
                    
                    // Check if player shot the cannon
                    for (let j = lasers.length - 1; j >= 0; j--) {
                        const laser = lasers[j];
                        if (laser.x > cannon.x - cannon.width / 2 && 
                            laser.x < cannon.x + cannon.width / 2 &&
                            laser.y > cannon.y - cannon.height && 
                            laser.y < cannon.y) {
                            cannon.destroyed = true;
                            lasers.splice(j, 1);
                            game.score += CONSTANTS.CANNON_POINTS;
                            updateScore();
                            playExplosion();
                            regenerateShieldsFromDestruction();
                            break;
                        }
                    }
                    
                    // Remove off-screen or destroyed cannons
                    if (cannon.x + cannon.width < 0 || cannon.destroyed) {
                        cannons.splice(i, 1);
                    }
                }
                
                // Update enemy lasers
                for (let i = enemyLasers.length - 1; i >= 0; i--) {
                    const eLaser = enemyLasers[i];
                    eLaser.x += eLaser.speed * Math.cos(eLaser.angle) * deltaTime;
                    eLaser.y += eLaser.speed * Math.sin(eLaser.angle) * deltaTime;
                    
                    // Check if enemy laser hit ship
                    const distance = Math.sqrt(
                        Math.pow(eLaser.x - (ship.x + ship.width / 2), 2) +
                        Math.pow(eLaser.y - (ship.y + ship.height / 2), 2)
                    );
                    
                    if (distance < 15) {
                        damageShip(CONSTANTS.ENEMY_LASER_DAMAGE);
                        enemyLasers.splice(i, 1);
                        continue;
                    }
                    
                    // Remove off-screen enemy lasers
                    if (eLaser.x < 0 || eLaser.x > canvas.width || 
                        eLaser.y < 0 || eLaser.y > canvas.height) {
                        enemyLasers.splice(i, 1);
                    }
                }
            }
            
            // Update obstacles
            obstacleSpawnTimer += deltaTime;
            if (obstacleSpawnTimer > CONSTANTS.OBSTACLE_SPAWN_INTERVAL_FRAMES) {
                spawnObstacle();
                obstacleSpawnTimer = 0;
            }
            
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.x -= CONSTANTS.SCROLL_SPEED * deltaTime;
                
                // Check laser collisions
                for (let j = lasers.length - 1; j >= 0; j--) {
                    if (checkCollision(lasers[j], obs)) {
                        obs.destroyed = true;
                        lasers.splice(j, 1);
                        game.score += CONSTANTS.OBSTACLE_POINTS;
                        updateScore();
                        playExplosion();
                        regenerateShieldsFromDestruction();
                        break;
                    }
                }
                
                // Check ship collision
                if (!obs.destroyed && checkCollision(ship, obs)) {
                    obs.destroyed = true;
                    damageShip(CONSTANTS.OBSTACLE_DAMAGE);
                    playExplosion();
                }
                
                // Remove off-screen or destroyed obstacles
                if (obs.x + obs.width < 0 || obs.destroyed) {
                    obstacles.splice(i, 1);
                }
            }
            
            // Update terrain scroll
            game.terrainOffset += CONSTANTS.SCROLL_SPEED * deltaTime;
            
            // Update stars - scroll slowly to the left
            for (let star of stars) {
                star.x -= CONSTANTS.SCROLL_SPEED * CONSTANTS.STAR_PARALLAX_FACTOR * deltaTime;
                
                // Wrap around when star goes off left edge
                if (star.x < 0) {
                    star.x = canvas.width;
                    star.y = Math.random() * canvas.height;
                }
            }
            
            // Shift terrain points
            while (game.terrainOffset > terrain.segmentWidth) {
                game.terrainOffset -= terrain.segmentWidth;
                
                // Remove first point and add new one at the end
                terrain.points.shift();
                
                const lastPoint = terrain.points[terrain.points.length - 1];
                let newY = lastPoint.y + (Math.random() - 0.5) * 40;
                newY = Math.max(canvas.height - CONSTANTS.TERRAIN_MAX_HEIGHT, Math.min(canvas.height - CONSTANTS.TERRAIN_MIN_HEIGHT, newY));
                
                terrain.points.push({
                    x: lastPoint.x + terrain.segmentWidth,
                    y: newY
                });
            }
            
            // Shift all terrain points left
            for (let point of terrain.points) {
                point.x -= CONSTANTS.SCROLL_SPEED * deltaTime;
            }
        }
        
        function damageShip(amount) {
            ship.shields -= amount;
            ship.timeSinceLastDamage = 0; // Reset regeneration timer
            ship.shieldsFullSoundPlayed = false; // Allow sound to play again when shields refill
            updateShields();
            
            if (ship.shields <= 0) {
                destroyShip();
            }
        }
        
        function regenerateShieldsFromDestruction() {
            // Only regenerate if delay period has passed
            if (ship.timeSinceLastDamage >= CONSTANTS.SHIELD_REGEN_DELAY_SECONDS) {
                if (ship.shields < ship.maxShields) {
                    const wasNotFull = ship.shields < ship.maxShields;
                    ship.shields = Math.min(ship.maxShields, ship.shields + CONSTANTS.SHIELD_REGEN_PER_OBJECT);
                    updateShields();
                    
                    // Play sound when shields reach 100%
                    if (wasNotFull && ship.shields >= ship.maxShields && !ship.shieldsFullSoundPlayed) {
                        playShieldsFullTone();
                        ship.shieldsFullSoundPlayed = true;
                    }
                }
            }
        }
        
        function destroyShip() {
            game.isGameOver = true;
            game.respawnTimer = 0;
            document.getElementById('gameOver').style.display = 'block';
            playExplosion();
        }
        
        function respawnShip() {
            ship.shields = ship.maxShields;
            ship.x = CONSTANTS.SHIP_START_X;
            ship.y = CONSTANTS.SHIP_START_Y;
            ship.vx = 0;
            ship.vy = 0;
            ship.timeSinceLastDamage = 0;
            ship.shieldsFullSoundPlayed = true; // Don't play sound on respawn
            game.isGameOver = false;
            document.getElementById('gameOver').style.display = 'none';
            updateShields();
        }
        
        function completeDocking() {
            const config = getCurrentLevelConfig();
            
            game.isDocked = true;
            game.dockingTimer = 0;
            game.countdownActive = false;
            playDockingSuccess();
            document.getElementById('levelComplete').style.display = 'block';
            document.getElementById('dockingHint').style.display = 'none';
            document.getElementById('countdown').style.display = 'none';
            
            // Bonus points for completing level
            game.score += config.levelCompleteBonus;
            updateScore();
        }
        
        function startCountdown() {
            game.countdownActive = true;
            game.countdownMs = CONSTANTS.DOCKING_COUNTDOWN_SECONDS * 1000;
            updateCountdownDisplay();
            document.getElementById('countdown').style.display = 'block';
        }
        
        function updateCountdownDisplay() {
            const countdownEl = document.getElementById('countdown');
            const countdownTime = Math.ceil(game.countdownMs / 1000);
            countdownEl.textContent = `DOCK IN: ${countdownTime}`;
            
            // Make it critical (red) when time is low
            if (countdownTime <= CONSTANTS.DOCKING_CRITICAL_THRESHOLD) {
                countdownEl.classList.add('critical');
            } else {
                countdownEl.classList.remove('critical');
            }
        }
        
        function timeoutDocking() {
            // Player failed to dock in time
            game.countdownActive = false;
            document.getElementById('countdown').style.display = 'none';
            document.getElementById('dockingHint').style.display = 'none';
            
            // Respawn ship and reset countdown
            ship.x = CONSTANTS.SHIP_START_X;
            ship.y = CONSTANTS.SHIP_START_Y;
            ship.vx = 0;
            ship.vy = 0;
            
            // Station stays but countdown restarts
            startCountdown();
            document.getElementById('dockingHint').style.display = 'block';
            
            playExplosion();
        }
        
        function nextLevel() {
            game.level++;
            game.levelElapsedMs = 0;
            game.isDocked = false;
            game.countdownActive = false;
            game.powerUpSpawned = false;
            game.bombPowerUpTimer = 0;
            
            // Set level duration from config
            const config = getCurrentLevelConfig();
            game.levelDurationMs = config.durationSeconds * 1000;
            
            // Reset ship
            ship.shields = ship.maxShields;
            ship.x = CONSTANTS.SHIP_START_X;
            ship.y = CONSTANTS.SHIP_START_Y;
            ship.vx = 0;
            ship.vy = 0;
            ship.timeSinceLastDamage = 0;
            ship.shieldsFullSoundPlayed = true; // Don't play sound on level start
            
            // Clear obstacles and power-ups
            obstacles.length = 0;
            powerUps.length = 0;
            bombPowerUps.length = 0;
            bombs.length = 0;
            cannons.length = 0;
            enemyLasers.length = 0;
            
            // Reset station
            station.active = false;
            station.isVisible = false;
            
            // Update UI
            document.getElementById('levelComplete').style.display = 'none';
            document.getElementById('countdown').style.display = 'none';
            document.getElementById('level').textContent = `LEVEL: ${game.level}`;
            updateShields();
            updateBombCount();
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `SCORE: ${game.score}`;
        }
        
        function updateShields() {
            const percentage = (ship.shields / ship.maxShields) * 100;
            document.getElementById('shieldFill').style.width = `${Math.max(0, percentage)}%`;
        }
        
        function updateSoundIndicator() {
            const indicator = document.getElementById('soundIndicator');
            if (game.soundEnabled) {
                indicator.textContent = 'ðŸ”Š';
                indicator.classList.remove('muted');
            } else {
                indicator.textContent = 'ðŸ”‡';
                indicator.classList.add('muted');
            }
        }
        
        function updatePauseDisplay() {
            const pauseOverlay = document.getElementById('pauseOverlay');
            if (game.isPaused) {
                pauseOverlay.style.display = 'block';
            } else {
                pauseOverlay.style.display = 'none';
            }
        }
        
        function updateBombCount() {
            const bombCountEl = document.getElementById('bombCount');
            if (game.level >= 4) {
                bombCountEl.style.display = 'block';
                bombCountEl.textContent = `BOMBS: ${game.bombCount}`;
            } else {
                bombCountEl.style.display = 'none';
            }
        }
        
        // Draw function
        function draw() {
            const theme = getCurrentTheme(game.level);
            
            // Clear canvas
            ctx.fillStyle = '#000814';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars background with theme-based tinting
            for (let star of stars) {
                const tint = theme.starTint;
                const alpha = star.brightness;
                ctx.fillStyle = `hsla(${tint.h}, ${tint.s}%, ${tint.l}%, ${alpha})`;
                ctx.fillRect(star.x, star.y, star.size, star.size);
            }
            
            // Draw terrain with theme colors and gradient
            const terrainFill = theme.terrainFill;
            const terrainStroke = theme.terrainStroke;
            
            // Create gradient for terrain
            const gradient = ctx.createLinearGradient(0, canvas.height - 200, 0, canvas.height);
            gradient.addColorStop(0, `hsl(${terrainFill.h}, ${terrainFill.s}%, ${terrainFill.l}%)`);
            gradient.addColorStop(1, `hsl(${terrainFill.h}, ${terrainFill.s - 10}%, ${terrainFill.l - 8}%)`);
            
            ctx.fillStyle = gradient;
            ctx.strokeStyle = `hsl(${terrainStroke.h}, ${terrainStroke.s}%, ${terrainStroke.l}%)`;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(-10, canvas.height);
            
            for (let i = 0; i < terrain.points.length; i++) {
                const point = terrain.points[i];
                ctx.lineTo(point.x, point.y);
            }
            
            ctx.lineTo(canvas.width + 10, canvas.height);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw obstacles
            for (let obs of obstacles) {
                if (!obs.destroyed) {
                    // Draw asteroid-like obstacle with irregular round shape
                    ctx.fillStyle = obs.fillColor;
                    ctx.strokeStyle = obs.strokeColor;
                    ctx.lineWidth = 2;
                    
                    ctx.beginPath();
                    const sides = 12; // More sides for rounder appearance
                    const centerX = obs.x + obs.width / 2;
                    const centerY = obs.y + obs.height / 2;
                    const baseRadius = obs.width / 2;
                    
                    for (let i = 0; i <= sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        // Create irregular bumpy surface with multiple sine waves
                        const variation = Math.sin(angle * 3) * 0.15 + Math.sin(angle * 5) * 0.1;
                        const radius = baseRadius * (1 + variation);
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Add crater details for more asteroid-like appearance (darker version of stroke color)
                    ctx.fillStyle = obs.strokeColor;
                    const craterCount = 2 + Math.floor(obs.width / 15);
                    for (let i = 0; i < craterCount; i++) {
                        const craterAngle = (i / craterCount) * Math.PI * 2 + obs.width;
                        const craterDist = baseRadius * 0.4;
                        const craterX = centerX + Math.cos(craterAngle) * craterDist;
                        const craterY = centerY + Math.sin(craterAngle) * craterDist;
                        const craterSize = baseRadius * 0.15;
                        
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Draw power-ups (blue diamonds)
            for (let powerUp of powerUps) {
                if (!powerUp.destroyed) {
                    ctx.save();
                    ctx.translate(powerUp.x, powerUp.y);
                    ctx.rotate(powerUp.rotation);
                    
                    // Draw diamond shape
                    ctx.fillStyle = '#00bfff';
                    ctx.strokeStyle = '#0080ff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00bfff';
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -powerUp.size); // Top
                    ctx.lineTo(powerUp.size, 0); // Right
                    ctx.lineTo(0, powerUp.size); // Bottom
                    ctx.lineTo(-powerUp.size, 0); // Left
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            }
            
            // Draw bomb power-ups (red dots)
            for (let bombPU of bombPowerUps) {
                if (!bombPU.destroyed) {
                    ctx.fillStyle = '#ff0000';
                    ctx.strokeStyle = '#cc0000';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff0000';
                    
                    ctx.beginPath();
                    ctx.arc(bombPU.x, bombPU.y, bombPU.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                }
            }
            
            // Draw bombs (dark blue heat-seeking)
            for (let bomb of bombs) {
                ctx.fillStyle = '#000080';
                ctx.strokeStyle = '#0000cc';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#0000ff';
                
                // Draw bomb as rounded rectangle
                ctx.beginPath();
                ctx.arc(bomb.x, bomb.y, bomb.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Draw trail
                ctx.strokeStyle = '#4444ff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(bomb.x, bomb.y);
                ctx.lineTo(bomb.x - bomb.vx * 2, bomb.y - bomb.vy * 2);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
            }
            
            // Draw laser cannons
            for (let cannon of cannons) {
                if (!cannon.destroyed) {
                    ctx.save();
                    
                    // Draw base
                    ctx.fillStyle = '#444';
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.fillRect(cannon.x - cannon.width / 2, cannon.y - cannon.height, cannon.width, cannon.height);
                    ctx.strokeRect(cannon.x - cannon.width / 2, cannon.y - cannon.height, cannon.width, cannon.height);
                    
                    // Draw barrel (rotates to track player)
                    ctx.translate(cannon.x, cannon.y - cannon.height / 2);
                    ctx.rotate(cannon.barrelAngle);
                    
                    ctx.fillStyle = '#555';
                    ctx.strokeStyle = '#777';
                    ctx.fillRect(0, -3, 25, 6);
                    ctx.strokeRect(0, -3, 25, 6);
                    
                    // Barrel tip glow
                    ctx.fillStyle = '#f00';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#f00';
                    ctx.beginPath();
                    ctx.arc(25, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    ctx.restore();
                }
            }
            
            // Draw enemy lasers
            ctx.fillStyle = '#f00';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#f00';
            
            for (let eLaser of enemyLasers) {
                ctx.save();
                ctx.translate(eLaser.x, eLaser.y);
                ctx.rotate(eLaser.angle);
                ctx.fillRect(0, -eLaser.height / 2, eLaser.width, eLaser.height);
                ctx.restore();
            }
            
            ctx.shadowBlur = 0;
            
            // Draw space station
            if (station.active) {
                // Main station body
                ctx.fillStyle = '#555';
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 3;
                
                // Central core
                ctx.fillRect(station.x + 40, station.y + 40, 70, 120);
                ctx.strokeRect(station.x + 40, station.y + 40, 70, 120);
                
                // Top module
                ctx.fillRect(station.x + 50, station.y, 50, 50);
                ctx.strokeRect(station.x + 50, station.y, 50, 50);
                
                // Bottom module
                ctx.fillRect(station.x + 50, station.y + 150, 50, 50);
                ctx.strokeRect(station.x + 50, station.y + 150, 50, 50);
                
                // Docking bay (left side opening)
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(station.dockingBay.x, station.dockingBay.y, station.dockingBay.width, station.dockingBay.height);
                
                // Docking bay indicator lights
                const isDockable = checkDocking();
                ctx.fillStyle = isDockable ? '#0f0' : '#f00';
                ctx.shadowBlur = 10;
                ctx.shadowColor = isDockable ? '#0f0' : '#f00';
                
                // Top light
                ctx.beginPath();
                ctx.arc(station.dockingBay.x + 10, station.dockingBay.y + 5, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Bottom light
                ctx.beginPath();
                ctx.arc(station.dockingBay.x + 10, station.dockingBay.y + station.dockingBay.height - 5, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Docking bay outline
                ctx.strokeStyle = isDockable ? '#0f0' : '#ff0';
                ctx.lineWidth = 2;
                ctx.strokeRect(station.dockingBay.x, station.dockingBay.y, station.dockingBay.width, station.dockingBay.height);
                
                // Windows on station
                ctx.fillStyle = '#ffff00';
                for (let i = 0; i < 8; i++) {
                    const wx = station.x + 60 + (i % 2) * 20;
                    const wy = station.y + 60 + Math.floor(i / 2) * 25;
                    ctx.fillRect(wx, wy, 8, 8);
                }
                
                // Antenna
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(station.x + 75, station.y);
                ctx.lineTo(station.x + 75, station.y - 30);
                ctx.stroke();
                
                // Antenna light
                ctx.fillStyle = '#f00';
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#f00';
                ctx.beginPath();
                ctx.arc(station.x + 75, station.y - 30, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // Draw lasers
            ctx.shadowBlur = 10;
            
            for (let laser of lasers) {
                // Make lasers cyan when dual-shot is active
                ctx.fillStyle = game.dualShotActive ? '#0ff' : '#0f0';
                ctx.shadowColor = game.dualShotActive ? '#0ff' : '#0f0';
                ctx.fillRect(laser.x, laser.y, laser.width, laser.height);
            }
            
            ctx.shadowBlur = 0;
            
            // Draw ship
            if (!game.isGameOver) {
                // Ship body
                ctx.fillStyle = '#00aaff';
                ctx.strokeStyle = '#0088cc';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(ship.x + ship.width, ship.y + ship.height / 2); // Nose
                ctx.lineTo(ship.x, ship.y); // Top back
                ctx.lineTo(ship.x, ship.y + ship.height); // Bottom back
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Cockpit
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(ship.x + ship.width * 0.6, ship.y + ship.height / 2, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Boost flame
                if (ship.acceleration > 0) {
                    const flameLength = 20 + ship.acceleration * 10;
                    
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(ship.x, ship.y + ship.height * 0.3);
                    ctx.lineTo(ship.x - flameLength, ship.y + ship.height / 2);
                    ctx.lineTo(ship.x, ship.y + ship.height * 0.7);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.moveTo(ship.x, ship.y + ship.height * 0.4);
                    ctx.lineTo(ship.x - flameLength * 0.6, ship.y + ship.height / 2);
                    ctx.lineTo(ship.x, ship.y + ship.height * 0.6);
                    ctx.fill();
                }
            } else {
                // Draw explosion
                const explosionSize = (game.respawnTimer % 30) * 2;
                ctx.fillStyle = `rgba(255, ${100 - game.respawnTimer * 2}, 0, ${1 - game.respawnTimer / 120})`;
                
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const radius = explosionSize + Math.random() * 20;
                    const x = ship.x + ship.width / 2 + Math.cos(angle) * radius;
                    const y = ship.y + ship.height / 2 + Math.sin(angle) * radius;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Game loop
        function gameLoop(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / CONSTANTS.TARGET_FRAME_TIME;
            lastTime = currentTime;
            
            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Start game
        function initGame() {
            const config = getCurrentLevelConfig();
            game.levelDurationMs = config.durationSeconds * 1000;
            updateScore();
            updateShields();
            updateSoundIndicator();
            requestAnimationFrame(gameLoop);
        }
        
        initGame();
    </script>
</body>
</html>
