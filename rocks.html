<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Rocks</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <!-- ... existing meta tags ... -->
    <link rel="preload" href="boss-ufo-1.png" as="image" type="image/png">
    <link rel="preload" href="boss-ufo-2.png" as="image" type="image/png">
    <link rel="preload" href="boss-ufo-3.png" as="image" type="image/png">
    <link rel="preload" href="boss-ufo-4.png" as="image" type="image/png">
    <link rel="preload" href="randomship.png" as="image" type="image/png">
    
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="score-container">Lives: <span id="lives">3</span> | Score: <span id="score">0</span> | Difficulty: <span id="difficulty-text">Mid</span></div>

    <div id="game-over" class="dialog-box">
        <h2>GAME OVER</h2>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-btn">Play Again</button>
    </div>

    <div id="pause-dialog" class="dialog-box">
        <h2>Game Paused</h2>
        <button id="resume-btn">Continue</button>
        <button id="start-over-btn">Start Over</button>
    </div>


    <div id="start-dialog" class="dialog-box">
        <h2>Select Difficulty</h2>
        <select id="difficulty-select">
            <option value="1">Mid</option>
            <option value="2">Skibidi</option>
            <option value="3">Cracked</option>
            <option value="4">GOAT</option>
        </select>
        <div id="speed-control">
            <label for="speed-slider">Game Speed:</label>
            <input type="range" id="speed-slider" min="0.5" max="2" step="0.1" value="1">
            <span id="speed-value">1.0x</span>
        </div>
        <button id="start-btn">Yeet</button>
    </div>

    <div id="fps-counter" style="position: fixed; bottom: 10px; right: 10px; color: cyan; font-family: monospace;"></div>
</div>

<!-- Audio elements -->
<audio id="shootSound" src="laser.mp3" preload="auto"></audio>
<audio id="explosionSound" src="explosion.mp3" preload="auto"></audio>
<audio id="shipExplodeSound" src="shipexplode.mp3" preload="auto"></audio>
<audio id="thrusterSound" src="thrust.mp3" preload="auto" loop></audio>
<audio id="randomShipSound" src="randomship.mp3" preload="auto"></audio>

<script>
// Game constants and variables
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const GAME_WIDTH = canvas.width;
const GAME_HEIGHT = canvas.height;

// how often to spawn a random ufo
RANDOMSHIP_SPAWN_INTERVAL = 60000;

const FIXED_TIME_STEP = 16.67; // ~60 FPS
let accumulator = 0;

const gameImages = {
    loaded: false,
    images: {}
};

let gameState = {
    speedMultiplier: 1,
    fpsCounter: 0,
    frames: 0,
    lastFpsUpdate: 0,
    score: 0,
    lives: 3,
    difficultyLevel: 1,
    difficultyText: 'Mid',
    isGameOver: false,
    isPaused: false,
    isInBossLevel: false,
    bossLevelNumber: 1,
    lastTime: 0,
    asteroids: [],
    bullets: [],
    ufoBullets: [],
    ufos: [],
    particles: [],
    keys: {
        ArrowUp: false,
        ArrowLeft: false,
        ArrowRight: false,
        Space: false
    }
};

// Audio elements
const sounds = {
    shoot: document.getElementById('shootSound'),
    explosion: document.getElementById('explosionSound'),
    shipExplode: document.getElementById('shipExplodeSound'),
    thruster: document.getElementById('thrusterSound'),
    randomShip: document.getElementById('randomShipSound')
};

// Set appropriate volumes
sounds.shoot.volume = 0.3;
sounds.explosion.volume = 0.2;
sounds.shipExplode.volume = 0.3;
sounds.thruster.volume = 0.4;
sounds.randomShip.volume = 0.4;

// Base class for game objects
class GameObject {
    constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    checkBoundaries() {
        // Screen wrapping
        if (this.x < -this.radius) this.x = GAME_WIDTH + this.radius;
        else if (this.x > GAME_WIDTH + this.radius) this.x = -this.radius;

        if (this.y < -this.radius) this.y = GAME_HEIGHT + this.radius;
        else if (this.y > GAME_HEIGHT + this.radius) this.y = -this.radius;
    }
}

// Player ship class
class PlayerShip extends GameObject {
    constructor(x, y) {
        super(x, y, 15);
        this.angle = 0;
        this.rotation = 0;
        this.thrusting = false;
        this.thrust = { x: 0, y: 0 };
        this.invulnerable = false;
        this.invulnerableTime = 0;
        this.canShoot = true;
        this.shootDelay = 300; // milliseconds
        this.bulletCount = 1; // Gain more bullets as player progresses
        this.maxBulletCount = 4; // max bullets to accumulate after each boss
        this.isToggleInvulnerable = false; // Track if invulnerability is toggled

    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Set color based on state
        ctx.strokeStyle = this.invulnerable ? '#FF0000' : 'white';
        ctx.fillStyle = this.invulnerable ? 'rgba(255, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.3)';
        
        // Draw ship
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.radius, 0);
        ctx.lineTo(-this.radius, -this.radius / 2);
        ctx.lineTo(-this.radius / 2, 0);
        ctx.lineTo(-this.radius, this.radius / 2);
        ctx.lineTo(this.radius, 0);
        ctx.closePath();
        ctx.stroke();
        ctx.fill();

        // Draw thrust flame if thrusting
        if (this.thrusting) {
            ctx.beginPath();
            ctx.moveTo(-this.radius, 0);
            ctx.lineTo(-this.radius - 10, 0);
            ctx.lineTo(-this.radius - Math.random() * 5, Math.random() * 6 - 3);
            ctx.closePath();
            ctx.strokeStyle = '#FFA500';
            ctx.stroke();
        }

        ctx.restore();
    }

    toggleInvulnerability() {
        //if (!this.isToggleInvulnerable) return;
        this.invulnerable = !this.invulnerable;
        if (this.invulnerable) {
            this.invulnerableTime = Infinity; // Set to infinity for toggle mode
        }
    }

    update(deltaTime) {
        // Update invulnerability timer
        if (this.invulnerable && this.invulnerableTime !== Infinity) {
            this.invulnerableTime -= deltaTime;
            if (this.invulnerableTime <= 0) {
                this.invulnerable = false;
            }
        }

        // Rest of the existing update code...
        this.angle += this.rotation;

        // Thrust
        if (this.thrusting) {
            this.thrust.x += Math.cos(this.angle) * 0.1;
            this.thrust.y += Math.sin(this.angle) * 0.1;

            // Create thrust particles
            createParticle(
                this.x - Math.cos(this.angle) * this.radius,
                this.y - Math.sin(this.angle) * this.radius,
                Math.random() * 2 + 1,
                Math.random() * 2 * Math.PI,
                'rgba(255, 100, 0, ' + (Math.random() * 0.5 + 0.5) + ')',
                Math.random() * 300 + 200
            );
        } else {
            // Apply friction when not thrusting
            this.thrust.x *= 0.98;
            this.thrust.y *= 0.98;
        }

        // Speed limit
        const maxSpeed = 6;
        const speed = Math.sqrt(this.thrust.x * this.thrust.x + this.thrust.y * this.thrust.y);
        if (speed > maxSpeed) {
            this.thrust.x *= maxSpeed / speed;
            this.thrust.y *= maxSpeed / speed;
        }

        // Movement
        this.x += this.thrust.x;
        this.y += this.thrust.y;

        // Screen wrapping
        this.checkBoundaries();
    }

    makeInvulnerable(duration) {
        this.invulnerable = true;
        this.invulnerableTime = duration;
    }

    shoot() {
        if (!this.canShoot) return;

        // Spread bullets based on bullet count
        const angleSpread = Math.min(0.3, (this.bulletCount - 1) * 0.1);
        const baseAngle = this.angle - (angleSpread / 2) * (this.bulletCount - 1);

        for (let i = 0; i < this.bulletCount; i++) {
            const bulletAngle = baseAngle + angleSpread * i;
            const bullet = new Bullet(
                this.x + Math.cos(bulletAngle) * this.radius,
                this.y + Math.sin(bulletAngle) * this.radius,
                Math.cos(bulletAngle) * 8,
                Math.sin(bulletAngle) * 8
            );
            gameState.bullets.push(bullet);
        }

        // Play shoot sound
        playSound(sounds.shoot);

        // Rate limiting
        this.canShoot = false;
        setTimeout(() => { this.canShoot = true; }, this.shootDelay);        

    }

    reset() {
        this.x = GAME_WIDTH / 2;
        this.y = GAME_HEIGHT / 2;
        this.angle = 0;
        this.thrust.x = 0;
        this.thrust.y = 0;
        this.rotation = 0;
        this.invulnerable = false;
        this.invulnerableTime = 0;
        this.isToggleInvulnerable = true;

        // ? this.makeInvulnerable(3000); // 3 seconds of invulnerability

        
        // Stop thruster sound
        sounds.thruster.pause();
        sounds.thruster.currentTime = 0;        
    }
}

// Space rock (asteroid) class
class SpaceRock extends GameObject {
    constructor(x, y, radius, level = 1) {
        super(x, y, radius);
        this.level = level;
        this.speed = Math.random() * 2 + 0.5;
        this.angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;

        // Create a random shape for the asteroid
        this.vertices = [];
        const vertexCount = Math.floor(Math.random() * 6) + 7;
        for (let i = 0; i < vertexCount; i++) {
            const angle = (i / vertexCount) * Math.PI * 2;
            const vertRadius = radius * (0.8 + Math.random() * 0.4);
            this.vertices.push({
                angle: angle,
                radius: vertRadius
            });
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();

        for (let i = 0; i < this.vertices.length; i++) {
            const vertex = this.vertices[i];
            const x = Math.cos(vertex.angle) * vertex.radius;
            const y = Math.sin(vertex.angle) * vertex.radius;

            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }

        ctx.closePath();
        ctx.stroke();
        ctx.restore();
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.checkBoundaries();
    }

    breakApart() {
        if (this.radius < 20) {
            return []; // Too small to break apart
        }

        const newAsteroids = [];
        for (let i = 0; i < 2; i++) {
            const newAsteroid = new SpaceRock(
                this.x + (Math.random() * 10 - 5),
                this.y + (Math.random() * 10 - 5),
                this.radius / 2,
                this.level + 1
            );
            newAsteroids.push(newAsteroid);
        }

        return newAsteroids;
    }
}

// Bullet class (player projectiles)
class Bullet extends GameObject {
    constructor(x, y, vx, vy) {
        super(x, y, 2);
        this.vx = vx;
        this.vy = vy;
        this.lifeTime = 1500; // 1.5 seconds
        this.alive = true;
    }

    draw() {
        ctx.save();
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    update(deltaTime) {
        this.x += this.vx;
        this.y += this.vy;
        this.checkBoundaries();

        // Reduce lifetime
        this.lifeTime -= deltaTime;
        if (this.lifeTime <= 0) {
            this.alive = false;
        }
    }
}

// UFO Bullet class (enemy projectiles)
class UFOBullet extends GameObject {
    constructor(x, y, vx, vy, color = 'red') {
        super(x, y, 3);
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.alive = true;
    }

    draw() {
        ctx.save();
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        // Check if bullet is out of bounds
        if (this.x < -this.radius || this.x > GAME_WIDTH + this.radius ||
            this.y < -this.radius || this.y > GAME_HEIGHT + this.radius) {
            this.alive = false;
        }
    }
}

// Base UFO class for both boss and random UFOs
class UFOBase extends GameObject {
    constructor(x, y, size, speed, direction, type) {
        super(x, y, size / 2);
        this.size = size;
        this.speed = speed;
        this.direction = direction; // 1 for right, -1 for left
        this.shootTimer = Math.random() * 1000 + 500;
        this.type = type; // 'boss' or 'random'
        this.bounceOffEdges = true;
    }

    draw() {
        // In a full implementation, this would load the proper image based on type and difficulty
        ctx.save();
        ctx.translate(this.x, this.y);

        // Simple UFO shape for demonstration
        ctx.strokeStyle = this.type === 'boss' ? '#FF00FF' : '#00FFFF';
        ctx.fillStyle = this.type === 'boss' ? 'rgba(255, 0, 255, 0.3)' : 'rgba(0, 255, 255, 0.3)';
        ctx.lineWidth = 2;

        // Draw UFO body
        ctx.beginPath();
        ctx.ellipse(0, 0, this.radius, this.radius / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Draw UFO dome
        ctx.beginPath();
        ctx.ellipse(0, -this.radius / 4, this.radius / 2, this.radius / 3, 0, Math.PI, 0);
        ctx.stroke();

        ctx.restore();
    }

    update(deltaTime) {
        // Move horizontally
        this.x += this.speed * this.direction;

        // Only bounce if bounceOffEdges is true
        if (this.bounceOffEdges && 
            (this.x < this.radius || this.x > GAME_WIDTH - this.radius)) {
            this.direction *= -1;
            this.y += this.size * 0.5;
            
            // Ensure UFO doesn't go below screen
            if (this.y > GAME_HEIGHT - this.radius) {
                this.y = GAME_HEIGHT - this.radius;
            }
        }

        // Update shoot timer
        this.shootTimer -= deltaTime;
        return this.shootTimer <= 0;
    }

    shoot(bulletSpeed, targetX, targetY) {
        // Reset shoot timer (random interval)
        this.shootTimer = Math.random() * 2000 + 1000;

        // Calculate direction to target
        const deltaX = targetX - this.x;
        const deltaY = targetY - this.y;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        // Bullet velocity
        let vx = (deltaX / distance) * bulletSpeed;
        let vy = (deltaY / distance) * bulletSpeed;

        // Add some randomness to aim for non-boss UFOs
        if (this.type === 'random') {
            vx += (Math.random() - 0.5) * 2;
            vy += (Math.random() - 0.5) * 2;
        }

        // Create and return the bullet
        return new UFOBullet(this.x, this.y, vx, vy);
    }
}

// Boss UFO class extends the base UFO
class BossShip extends UFOBase {
    constructor(x, y, difficulty) {
        const size = 40 + (difficulty * 5);
        const speed = 1.5 + (difficulty * 0.3);
        super(x, y, size, speed, Math.random() > 0.5 ? 1 : -1, 'boss');
        
        // Check if image is loaded in gameImages
        if (gameImages.images[`boss-ufo-${difficulty}`]) {
            this.image = gameImages.images[`boss-ufo-${difficulty}`];
            this.frameWidth = this.image.width;
            this.frameHeight = this.image.height;
        } else {
            console.warn(`Boss ship image for difficulty ${difficulty} not loaded yet`);
            // Set default dimensions for wireframe fallback
            this.frameWidth = this.size * 2;
            this.frameHeight = this.size * 2;
        }
        
        this.health = difficulty * 2;
        this.difficulty = difficulty;
        this.shootInterval = Math.max(500, 2000 - (difficulty * 300));
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Draw the boss ship image
        if (this.image) {
            // Use integer coordinates for better performance
            const x = Math.floor(-this.frameWidth / 2);
            const y = Math.floor(-this.frameHeight / 2);
            ctx.drawImage(this.image, x, y, this.frameWidth, this.frameHeight);
        } else {
            // Fallback to wireframe if image isn't loaded
            ctx.strokeStyle = '#FF00FF';
            ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
            ctx.lineWidth = 2;
            
            // Draw UFO body
            ctx.beginPath();
            ctx.ellipse(0, 0, this.radius, this.radius / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw UFO dome
            ctx.beginPath();
            ctx.ellipse(0, -this.radius / 4, this.radius / 2, this.radius / 3, 0, Math.PI, 0);
            ctx.stroke();
        }
        ctx.restore();
    }
}

// Random UFO class extends the base UFO
/**
 * Represents a randomly spawning UFO that moves across the screen.
 * Extends the base UFO class to include specific behavior for random UFOs.
 */
 class RandomShip extends UFOBase {
    /**
     * Creates an instance of RandomShip.
     * @param {number} y - The y-coordinate where the RandomShip will spawn.
     */

    constructor(y) {   
        const startX = Math.random() < 0.5 ? GAME_WIDTH : 0;
        const direction = startX === 0 ? 1 : -1;

        // Initialize parent class with y-position adjusted for top-left coordinate system
        // Using 30 as the size of the ship
        super(startX, 30, 30, 2.5, direction, 'random');
        
        console.log('RandomShip spawned at:', this.x, this.y);
        this.bounceOffEdges = false;

        // Sound setup for the RandomShip
        this.soundPlaying = false;
        this.sound = document.getElementById('randomShipSound');
        if (this.sound) {
            this.sound.loop = false;
        }
    }
    /**
     * Draws the RandomShip on the canvas.
     * Includes logic to play a sound effect when the ship is visible on the screen.
     */
    draw() {

        if (!this.x % 10)
            console.log('Drwing UFO on screen height:%d width:%d  at x:%d, y:%d, direction:%d, speed:%d', screen.height, screen.width, this.x, this.y, this.direction, this.speed);

        // Check if the RandomShip image is loaded
        if (!gameImages.images.randomship) {
            console.warn('Random ship image not loaded!');
        }

        // Draw the RandomShip image if available
        if (gameImages.images.randomship) {
            ctx.save();
            ctx.translate(this.x, this.y);

            ctx.drawImage(gameImages.images.randomship,
                -this.size / 2, -this.size / 2,
                this.size, this.size);
            ctx.restore();
        } else {
            // Fallback to a wireframe drawing if the image is not loaded
            console.warn('Random ship image not loaded! Using fallback wireframe.');
            super.draw();
        }

        // Play the sound effect when the RandomShip is visible on the screen
        if (!this.soundPlaying &&
            this.x > -50 && this.x < GAME_WIDTH + 50) {
            if (this.sound) {
                this.sound.currentTime = 0;
                this.sound.play().catch(console.error);
                this.soundPlaying = true;
            }
        }
    }

    /**
     * Updates the position and state of the RandomShip.
     * Moves the ship horizontally across the canvas.
     * @param {number} deltaTime - The time elapsed since the last update.
     * @returns {boolean} - Returns true if the ship is ready to shoot, false otherwise.
     */
    update(deltaTime) {
        
        //onsole.log('UFO position:', this.x, 'direction:', this.direction);

        // Move the ship horizontally based on its speed and direction
        this.x += this.speed * this.direction;

        // Update the shoot timer
        this.shootTimer -= deltaTime;

        // Return true if the ship is ready to shoot
        return this.shootTimer <= 0;
    }
}


// Particle class for visual effects
class Particle {
    constructor(x, y, radius, angle, color, lifeTime) {
        this.x = x;
        this.y = y;
        this.initialRadius = radius;
        this.radius = radius;
        this.angle = angle;
        this.speed = Math.random() * 3 + 1;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.color = color;
        this.initialLifeTime = lifeTime;
        this.lifeTime = lifeTime;
        this.alive = true;
    }

    draw() {
        ctx.save();
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, Math.max(0.1, this.radius), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    update(deltaTime) {
        this.x += this.vx;
        this.y += this.vy;

        // Fade out and shrink
        this.lifeTime -= deltaTime;
        const lifePercentage = Math.max(0, this.lifeTime / this.initialLifeTime);
        this.radius = this.initialRadius * lifePercentage;

        if (this.lifeTime <= 0) {
            this.alive = false;
        }
    }
}

// Helper Functions
function createParticle(x, y, radius, angle, color, lifeTime) {
    const particle = new Particle(x, y, radius, angle, color, lifeTime);
    gameState.particles.push(particle);
    return particle;
}

function createExplosion(x, y, color, count = 15) {
    for (let i = 0; i < count; i++) {
        createParticle(
            x,
            y,
            Math.random() * 3 + 1,
            Math.random() * Math.PI * 2,
            color,
            Math.random() * 500 + 500
        );
    }
}

function detectCollision(obj1, obj2) {
    if (obj1.invulnerable || obj2.invulnerable) return false;
    const dx = obj1.x - obj2.x;
    const dy = obj1.y - obj2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < obj1.radius + obj2.radius;
}

function playSound(sound) {
    sound.currentTime = 0;
    sound.play().catch(error => console.log('Audio playback failed:', error, sound));
}


function createAsteroids(count, playerX, playerY, minDistance = 200) {
    const asteroids = [];
    for (let i = 0; i < count; i++) {
        let x, y;
        // Ensure asteroids don't spawn too close to the player
        do {
            x = Math.random() * GAME_WIDTH;
            y = Math.random() * GAME_HEIGHT;
        } while (Math.sqrt((x - playerX) ** 2 + (y - playerY) ** 2) < minDistance);

        asteroids.push(new SpaceRock(x, y, 40 + Math.random() * 20));
    }
    return asteroids;
}

function getDifficultySettings(level) {
    const settings = {
        1: { // "Mid" (beginner)
            asteroidCount: 4,
            bossHealth: 2,
            bossCount: 1,
            text: 'Mid'
        },
        2: { // "Skibidi" (intermediate)
            asteroidCount: 6,
            bossHealth: 3,
            bossCount: 1,
            text: 'Skibidi'
        },
        3: { // "Cracked" (advanced)
            asteroidCount: 8,
            bossHealth: 4,
            bossCount: 2,
            text: 'Cracked'
        },
        4: { // "GOAT" (professional)
            asteroidCount: 10,
            bossHealth: 5,
            bossCount: 2,
            text: 'GOAT'
        }
    };

    return settings[level];
}

function startBossLevel() {
    const difficulty = gameState.difficultyLevel;
    const settings = getDifficultySettings(difficulty);

    // Create boss UFOs
    const bossCount = settings.bossCount * gameState.bossLevelNumber;
    const spacing = GAME_WIDTH / (bossCount + 1);

    gameState.ufos = [];
    for (let i = 0; i < bossCount; i++) {
        const x = spacing * (i + 1);
        const y = 50;
        gameState.ufos.push(new BossShip(x, y, difficulty));
    }

    // Clear UFO bullets and set boss level flag
    gameState.ufoBullets = [];
    gameState.isInBossLevel = true;
}

// Game state management
function init() {
    const player = new PlayerShip(GAME_WIDTH / 2, GAME_HEIGHT / 2);
    player.makeInvulnerable(3000); // 3 seconds of invulnerability at start

    // Get difficulty settings
    const difficulty = gameState.difficultyLevel;
    const settings = getDifficultySettings(difficulty);
    gameState.difficultyText = settings.text;

    // Create initial asteroids
    const asteroids = createAsteroids(settings.asteroidCount, player.x, player.y);

    // Reset game state
    gameState.player = player;
    gameState.asteroids = asteroids;
    gameState.bullets = [];
    gameState.ufos = [];
    gameState.ufoBullets = [];
    gameState.particles = [];
    gameState.score = 0;
    gameState.lives = 3;
    gameState.isGameOver = false;
    gameState.isPaused = false;
    gameState.isInBossLevel = false;
    gameState.bossLevelNumber = 1;
    gameState.lastTime = 0;
    gameState.lastUFOSpawnTime = Date.now(); // Set to current time
    gameState.UFOSpawnInterval = RANDOMSHIP_SPAWN_INTERVAL;

    // Reset keys
    gameState.keys = {
        ArrowUp: false,
        ArrowLeft: false,
        ArrowRight: false,
        Space: false
    };

    // Update UI
    updateUI();
}

function updateUI() {
    document.getElementById('score').textContent = gameState.score;
    document.getElementById('lives').textContent = gameState.lives;
    document.getElementById('difficulty-text').textContent = gameState.difficultyText;
}

function endGame() {
    gameState.isGameOver = true;

    // Stop sounds
    sounds.thruster.pause();
    sounds.thruster.currentTime = 0;

    // Update UI
    document.getElementById('final-score').textContent = gameState.score;
    document.getElementById('game-over').style.display = 'block';
}


function gameLoop(timestamp) {
    if (gameState.isGameOver || gameState.isPaused) return;
    
    // Update FPS counter
    gameState.frames++;
    const now = timestamp;
    if (now - gameState.lastFpsUpdate >= 1000) {
        gameState.fpsCounter = gameState.frames;
        gameState.frames = 0;
        gameState.lastFpsUpdate = now;
        document.getElementById('fps-counter').textContent = `FPS: ${gameState.fpsCounter}`;
    }
    
    // Calculate delta time
    const deltaTime = Math.min(timestamp - gameState.lastTime, 50);
    accumulator += deltaTime;
    gameState.lastTime = timestamp;

    // Calculate adjusted time step based on speed multiplier
    const adjustedTimeStep = FIXED_TIME_STEP / Math.pow(gameState.speedMultiplier, 1.5);

    // Update game state in fixed steps
    while (accumulator >= adjustedTimeStep) {
        updateGameLogic(adjustedTimeStep);
        accumulator -= adjustedTimeStep;
    }

    // Render at the current frame rate
    render();

    // Continue the game loop
    requestAnimationFrame(gameLoop);
}

function updateGameLogic(fixedStep) {
    // Process input
    processPlayerInput(fixedStep);

    // Update player
    if (gameState.player) {
        gameState.player.update(fixedStep);
    }

    // Update game objects with speed multiplier
    updateAsteroids(fixedStep);
    updateBullets(fixedStep);
    updateUFOs(fixedStep);
    updateParticles(fixedStep);

    // Check game state
    if (gameState.asteroids.length === 0 && !gameState.isInBossLevel) {
        startBossLevel();
    } else if (gameState.asteroids.length === 0 && gameState.isInBossLevel && gameState.ufos.length === 0) {
        gameState.bossLevelNumber++;
        gameState.isInBossLevel = false;
        if (gameState.player.bulletCount < gameState.player.maxBulletCount)
            gameState.player.bulletCount++ 
        const settings = getDifficultySettings(gameState.difficultyLevel);
        const newAsteroidCount = Math.min(settings.asteroidCount + Math.floor(gameState.bossLevelNumber / 2), 12);
        gameState.asteroids = createAsteroids(newAsteroidCount, gameState.player.x, gameState.player.y);
    }
}

function render() {
    // Clear canvas
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Draw game objects
    if (gameState.player) {
        gameState.player.draw();
    }
    gameState.asteroids.forEach(asteroid => asteroid.draw());
    gameState.bullets.forEach(bullet => bullet.draw());
    gameState.ufoBullets.forEach(bullet => bullet.draw());
    gameState.ufos.forEach(ufo => ufo.draw());
    gameState.particles.forEach(particle => particle.draw());
}

function processPlayerInput() {
    const player = gameState.player;
    const keys = gameState.keys;

    // Rotation
    if (keys.ArrowLeft) {
        player.rotation = -0.05;
    } else if (keys.ArrowRight) {
        player.rotation = 0.05;
    } else {
        player.rotation = 0;
    }

    // Thrust
    player.thrusting = keys.ArrowUp;

    // Handle thruster sound
    if (player.thrusting) {
        if (sounds.thruster.paused) {
            sounds.thruster.play().catch(error => console.log('Audio playback failed:', error));
        }
    } else {
        sounds.thruster.pause();
    }

    // Shooting
    if (keys.Space && player.canShoot) {
        player.shoot();
    }
}

function updateAsteroids() {
    for (let i = gameState.asteroids.length - 1; i >= 0; i--) {
        const asteroid = gameState.asteroids[i];
        asteroid.update();
        asteroid.draw();

        // Check for collision with player
        if (gameState.player && !gameState.player.invulnerable &&
            detectCollision(gameState.player, asteroid)) {

            // Create explosion
            createExplosion(gameState.player.x, gameState.player.y, 'rgba(255, 255, 255, 0.8)', 40);

            // Play explosion sound
            playSound(sounds.shipExplode);

            // Reduce lives
            gameState.lives--;
            updateUI();

            if (gameState.lives <= 0) {
                endGame();
                return;
            } else {
                gameState.player.reset();
            }
        }
    }
}

function updateBullets(deltaTime) {
    // Update player bullets
    for (let i = gameState.bullets.length - 1; i >= 0; i--) {
        const bullet = gameState.bullets[i];
        bullet.update(deltaTime);
        bullet.draw();

        // Check for collision with asteroids
        let hitAsteroid = false;
        for (let j = gameState.asteroids.length - 1; j >= 0 && !hitAsteroid; j--) {
            const asteroid = gameState.asteroids[j];
            if (detectCollision(bullet, asteroid)) {
                // Create explosion
                createExplosion(asteroid.x, asteroid.y, 'rgba(255, 255, 255, 0.8)', 20);

                // Play explosion sound
                playSound(sounds.explosion);

                // Add score based on asteroid size
                gameState.score += (4 - Math.floor(asteroid.radius / 10)) * 100;
                updateUI();

                // Break asteroid into smaller pieces
                const newAsteroids = asteroid.breakApart();
                gameState.asteroids.splice(j, 1);
                gameState.asteroids.push(...newAsteroids);

                // Remove the bullet
                gameState.bullets.splice(i, 1);
                hitAsteroid = true;
            }
        }

        // Check for collision with UFOs if not already hit an asteroid
        if (!hitAsteroid) {
            for (let j = gameState.ufos.length - 1; j >= 0; j--) {
                const ufo = gameState.ufos[j];
                if (detectCollision(bullet, ufo)) {
                    // Create explosion
                    createExplosion(ufo.x, ufo.y, ufo.type === 'boss' ? 'rgba(255, 0, 255, 0.8)' : 'rgba(0, 255, 255, 0.8)', 25);

                    // Play explosion sound
                    playSound(sounds.explosion);

                    // Add score
                    gameState.score += ufo.type === 'boss' ? 500 : 300;
                    updateUI();

                    // Remove UFO and bullet
                    gameState.ufos.splice(j, 1);
                    gameState.bullets.splice(i, 1);
                    hitAsteroid = true;
                    break;
                }
            }
        }

        // Remove bullet if it's expired
        if (!hitAsteroid && !bullet.alive) {
            gameState.bullets.splice(i, 1);
        }
    }

    // Update UFO bullets
    for (let i = gameState.ufoBullets.length - 1; i >= 0; i--) {
        const bullet = gameState.ufoBullets[i];
        bullet.update();
        bullet.draw();

        // Check for collision with player
        if (gameState.player && !gameState.player.invulnerable &&
            detectCollision(bullet, gameState.player)) {

            // Create explosion
            createExplosion(gameState.player.x, gameState.player.y, 'rgba(255, 255, 255, 0.8)', 40);

            // Play explosion sound
            playSound(sounds.shipExplode);

            // Remove the bullet
            gameState.ufoBullets.splice(i, 1);

            // Reduce lives
            gameState.lives--;
            updateUI();

            if (gameState.lives <= 0) {
                endGame();
                return;
            } else {
                gameState.player.reset();
            }
        }

        // Remove dead bullets
        if (!bullet.alive) {
            gameState.ufoBullets.splice(i, 1);
        }
    }
}

function updateUFOs(deltaTime) {
    // Remove UFOs that have moved off-screen
    for (let i = gameState.ufos.length - 1; i >= 0; i--) {
        const ufo = gameState.ufos[i];
        // Remove UFO if it's completely off-screen
        if ((ufo.x < -100 || ufo.x > GAME_WIDTH + 100)) {
            gameState.ufos.splice(i, 1);
        }
    }

    // Update existing UFOs
    for (let i = gameState.ufos.length - 1; i >= 0; i--) {
        const ufo = gameState.ufos[i];
        
        // Update UFO and check if it should shoot
        if (ufo.update(deltaTime) && gameState.player) {
            // Time to shoot - create bullet aimed at player
            const bullet = ufo.shoot(5, gameState.player.x, gameState.player.y);
            gameState.ufoBullets.push(bullet);
            // Play shoot sound (with lower volume for UFO shots)
            const tempVol = sounds.shoot.volume;
            sounds.shoot.volume = 0.2;
            // playSound(sounds.shoot);
            sounds.shoot.volume = tempVol;
        }
        
        ufo.draw();
        
        // Check for collision with player
        if (gameState.player && !gameState.player.invulnerable && 
            detectCollision(gameState.player, ufo)) {
            // Create explosion for both player and UFO
            createExplosion(gameState.player.x, gameState.player.y, 'rgba(255, 255, 255, 0.8)', 40);
            createExplosion(ufo.x, ufo.y, ufo.type === 'boss' ? 'rgba(255, 0, 255, 0.8)' : 'rgba(0, 255, 255, 0.8)', 25);
            // Play explosion sound
            playSound(sounds.shipExplode);
            // Add score for destroying UFO
            gameState.score += ufo.type === 'boss' ? 500 : 300;
            // Remove the UFO
            gameState.ufos.splice(i, 1);
            // Reduce lives
            gameState.lives--;
            updateUI();
            if (gameState.lives <= 0) {
                endGame();
                return;
            } else {
                gameState.player.reset();
            }
        }
        
        // Check for collision with asteroids
        for (let j = gameState.asteroids.length - 1; j >= 0; j--) {
            const asteroid = gameState.asteroids[j];
            if (detectCollision(ufo, asteroid)) {
                // Create explosions
                createExplosion(ufo.x, ufo.y, ufo.type === 'boss' ? 'rgba(255, 0, 255, 0.8)' : 'rgba(0, 255, 255, 0.8)', 25);
                createExplosion(asteroid.x, asteroid.y, 'rgba(255, 255, 255, 0.8)', 20);
                // Play explosion sound
                playSound(sounds.explosion);
                // Remove UFO
                gameState.ufos.splice(i, 1);
                // Break asteroid
                const newAsteroids = asteroid.breakApart();
                gameState.asteroids.splice(j, 1);
                gameState.asteroids.push(...newAsteroids);
                break;
            }
        }
    }

    // Occasionally spawn random UFOs during gameplay
    if (!gameState.isInBossLevel) {
        const spawnInterval = gameState.UFOSpawnInterval;
        const now = Date.now();
        
        if (!gameState.lastUFOSpawnTime || now - gameState.lastUFOSpawnTime >= spawnInterval) {
            const y = 50;
            const x = Math.random() < 0.5 ? -30 : GAME_WIDTH + 30;
            gameState.ufos.push(new RandomShip(x, y));
            gameState.lastUFOSpawnTime = now;
            
            // Generate next random spawn time within the interval
            gameState.nextUFOSpawnTime = now + Math.random() * spawnInterval;
        }
        
        // Check if it's time for the next spawn
        if (now >= gameState.nextUFOSpawnTime) {
            const y = 50;
            const x = Math.random() < 0.5 ? -30 : GAME_WIDTH + 30;
            gameState.ufos.push(new RandomShip(x, y));
            gameState.lastUFOSpawnTime = now;
            gameState.nextUFOSpawnTime = now + Math.random() * spawnInterval;
        }
    }
}

function updateParticles(deltaTime) {
    for (let i = gameState.particles.length - 1; i >= 0; i--) {
        const particle = gameState.particles[i];
        particle.update(deltaTime);
        particle.draw();

        if (!particle.alive) {
            gameState.particles.splice(i, 1);
        }
    }
}

// UI management
function showStartDialog() {
    document.getElementById('start-dialog').style.display = 'block';
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('pause-dialog').style.display = 'none';
}

function hideStartDialog() {
    document.getElementById('start-dialog').style.display = 'none';
    const difficultySelect = document.getElementById('difficulty-select');
    gameState.difficultyLevel = parseInt(difficultySelect.value);
    init();
    gameState.lastTime = 0;
    requestAnimationFrame(gameLoop);
}

function showPauseDialog() {
    gameState.isPaused = true;
    document.getElementById('pause-dialog').style.display = 'block';
}

function hidePauseDialog() {
    document.getElementById('pause-dialog').style.display = 'none';
    gameState.isPaused = false;
    gameState.lastTime = 0; // Reset lastTime to prevent huge delta on resume
    requestAnimationFrame(gameLoop);
}

// Event Listeners
window.addEventListener('keydown', (e) => {
    if (gameState.isPaused && e.code !== 'Escape' && e.code !== 'Space') return;

    if (e.code === 'ArrowUp') gameState.keys.ArrowUp = true;
    if (e.code === 'ArrowLeft') gameState.keys.ArrowLeft = true;
    if (e.code === 'ArrowRight') gameState.keys.ArrowRight = true;
    
    if (e.code === 'Space') {
        gameState.keys.Space = true;
        e.preventDefault(); // Prevent page scrolling

        // Resume from pause if Space is pressed
        if (gameState.isPaused) {
            hidePauseDialog();
        }
    }
    if (e.code === 'Escape') {
        if (gameState.isPaused) {
            hidePauseDialog();
        } else {
            showPauseDialog();
        }
    }
    if (e.ctrlKey && e.altKey && e.code === 'KeyI') {
        
        e.preventDefault();
        if (gameState.player) {
            console.log ('Invulnerability toggled');
            gameState.player.toggleInvulnerability();
        }
        return;
    }
    if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'u') {
        e.preventDefault();
        if (!gameState.isInBossLevel) {
            const y = 50;
            const x = Math.random() < 0.5 ? -30 : GAME_WIDTH + 30;
            const ufo = new RandomShip(x, y);
            gameState.ufos.push(ufo);

            // Play sound effect
            const randomShipSound = document.getElementById('randomShipSound');

            if (randomShipSound) {
                randomShipSound.currentTime = 0;
                randomShipSound.play().catch(console.error);
            }
        }
    }
});

window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowUp') gameState.keys.ArrowUp = false;
    if (e.code === 'ArrowLeft') gameState.keys.ArrowLeft = false;
    if (e.code === 'ArrowRight') gameState.keys.ArrowRight = false;
    if (e.code === 'Space') gameState.keys.Space = false;
});

// Button event listeners
document.getElementById('start-btn').addEventListener('click', hideStartDialog);
document.getElementById('restart-btn').addEventListener('click', showStartDialog);
document.getElementById('resume-btn').addEventListener('click', hidePauseDialog);
document.getElementById('start-over-btn').addEventListener('click', showStartDialog);

document.getElementById('speed-slider').addEventListener('input', (e) => {
    gameState.speedMultiplier = parseFloat(e.target.value);
    document.getElementById('speed-value').textContent = gameState.speedMultiplier.toFixed(1) + 'x';
});



// Load game images
function loadGameImages() {
    const difficulties = [1, 2, 3, 4];

    const imagesToLoad = [
        ...difficulties.map(difficulty => ({
            id: `boss-ufo-${difficulty}`,
            src: `boss-ufo-${difficulty}.png`
        })),
        {
            id: 'randomship',
            src: 'randomship.png'
        }
    ];
    
    let loadedCount = 0;
    
    imagesToLoad.forEach(asset => {
        const img = new Image();
        img.src = asset.src;
        img.onload = () => handleImageLoaded();
        gameImages.images[asset.id] = img;
        console.log(`Loaded image: ${asset.src}`);

        img.onerror = () => {
            console.error(`Failed to load image: ${asset.src}`);
        };
    });


    function handleImageLoaded() {
        loadedCount++;
        if (loadedCount === imagesToLoad.length) {
            gameImages.loaded = true;
        }
    }
}

// Show the start dialog when the page loads
window.addEventListener('load', showStartDialog);

// load boss images
window.addEventListener('load', loadGameImages);
</script>
</body>
</html>
